# Detection Accuracy{#preds_detect}

To this point we have:

1. Provided a data overview: [here](#data_desc) and [here](#data_load)
2. [Processed the UAS point cloud](#ptcld_process)
3. [Demonstrated our geometry-based slash pile detection methodology](#geom_detect)
4. [Demonstrated our spectral refinement (i.e. data fusion) methodology](#data_fusion)
5. [Reviewed how we will evaluate our method](#meth_eval)
6. [Made predictions using our method on four experimental sites](#meth_preds)
7. and [Evaluated the pile detection accuracy of the structural-plus-spectral data fusion methodology](#preds_detect)

In this section, we'll evaluate the effectiveness of the proposed geometric, rules-based slash pile detection methodology by assessing its quantification accuracy performance. We fully reviewed the quantification accuracy assessment [workflow here](#quant_metrics_form), but here is a quick overview:

While [detection accuracy](#preds_detect) evaluates the ability of the method to correctly locate slash piles, the quantification accuracy assessment measures the precision of the physical pile form dimensions estimated for the successfully identified piles. The quantification accuracy assessment focuses exclusively on TP matches to calculate performance metrics such as Root Mean Square Error (RMSE), Mean Absolute Percentage Error (MAPE), and Mean Error (ME) for pile form measurements height and diameter. Unlike the detection validation which includes all four study sites, this quantification accuracy evaluation is limited to the PSINF Mixed Conifer site where direct field-measured ground truth data is available. 

We intentionally limit the quantification accuracy reporting to measurements of height and diameter which were made directly in the field rather than derived volume. To evaluate volume, we will perform a direct comparison between the volumes calculated from our predicted segments and those calculated from field measurements using identical geometric formulas. This comparison functions as a test of measurement consistency rather than a formal accuracy assessment of the remote-sensing method itself. This approach ensures our quantification metrics reflect the actual performance of the detection method instead of a composite error involving sensor noise, field variance, and geometric assumptions. Because both the predicted and field-based volumes rely on the same simplified shape assumptions, any resulting differences are not treated as true errors. Instead, this evaluation highlights how variations in the primary inputs of height and diameter propagate through to the final volume estimate. This distinction is critical because it separates the verifiable accuracy of our sensor-derived physical pile form measurements from the subsequent modeling of three-dimensional space.

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

## Height and Diameter Accuracy

Let's evaluate the height and diameter accuracy of our slash pile detection and quantification framework using field measurements for the PSINF site which were taken by measuring the height and diameter (longest side of pile) using a laser hypsometer

We already computed the performance metrics RMSE, MAPE, and ME for pile form measurements height and diameter at the study site and detection methodology level in the [prior section](#agg_inst_match) using our `agg_ground_truth_match()` function that we [defined earlier](#quant_metrics_form)

let's check out what we got

```{r}
df_temp <- 
  agg_ground_truth_match_ans %>% 
  dplyr::mutate(
    ref_trees = tp_n+fn_n
    , det_trees = tp_n+fp_n
  ) %>% 
  dplyr::select(
    site, method
    # , site_area_m2
    # detection
    , ref_trees
    , det_trees
    , tp_n
    , omission_rate,commission_rate,recall,precision,f_score
    # quantification
    , tidyselect::ends_with("_mean")
    , tidyselect::ends_with("_rmse")
    , tidyselect::ends_with("_mape")
  ) %>% 
  # second select to arrange pile_metric
  dplyr::select(
    site, method
    # , site_area_m2
    # detection
    , ref_trees
    , det_trees
    , tp_n
    , omission_rate,commission_rate,recall,precision,f_score
    # quantification
    # , c(tidyselect::contains("volume") & !tidyselect::contains("paraboloid"))
    , tidyselect::contains("area")
    , tidyselect::contains("height")
    , tidyselect::contains("diameter")
  ) %>% 
  # names()
  dplyr::mutate(
    dplyr::across(
      .cols = c(
        f_score, recall, precision, tidyselect::ends_with("_mape")
        , tidyselect::ends_with("_rate")
      )
      , .fn = ~ scales::percent(.x, accuracy = 1)
    )
    , dplyr::across(
      .cols = c(tidyselect::ends_with("_mean"))
      , .fn = ~ scales::comma(.x, accuracy = 0.01)
    )
    , dplyr::across(
      .cols = c(tidyselect::ends_with("_rmse"))
      , .fn = ~ scales::comma(.x, accuracy = 0.1)
    )
  )
  # dplyr::glimpse()

  ########################## adj this if want lots of cols
df_temp %>% 
  dplyr::inner_join(
    all_stand_boundary %>% 
      sf::st_drop_geometry() %>% 
      dplyr::filter(site_data_lab == "psinf") %>% 
      dplyr::select(site,site_area_ha)
    , by = "site"
  ) %>% 
  dplyr::select(
    !tidyselect::contains("_area_")
    & !tidyselect::contains("diff_diameter_")
    & !tidyselect::ends_with("_trees")
    # & !tidyselect::ends_with("_n")
    & !tidyselect::ends_with("_rate")
  ) %>% 
  dplyr::select(
    -c(recall,precision,f_score)
  ) %>% 
  ########################## adj this if want lots of cols
  # dplyr::glimpse()
  dplyr::relocate(site,method,tp_n) %>% 
  dplyr::arrange(site,method) %>% 
  kableExtra::kbl(
    caption = "Quantification Accuracy"
    , col.names = c(
      "site", "method", "TP predictions"
      , rep(c("ME","RMSE","MAPE"), times = 2)
    )
    , escape = F
    # , digits = 2
  ) %>% 
  kableExtra::kable_styling(font_size = 11.5) %>% 
  kableExtra::add_header_above(c(
    " "=3
    # , "Detection" = 3
    # , "Area" = 3
    , "Height (m)" = 3
    , "Diameter (m)" = 3
  )) %>% 
  kableExtra::column_spec(seq(3,9,by=3), border_right = TRUE, include_thead = TRUE) %>% 
  # kableExtra::column_spec(
  #   column = 3:9
  #   , extra_css = "font-size: 10px;"
  #   , include_thead = T
  # ) %>% 
  kableExtra::collapse_rows(columns = 1, valign = "top")
```

These results demonstrate that the two segmentation methods, DBSCAN and Watershed, show no significant difference in their ability to represent the physical form of correctly identified piles. Because the quantification of pile form is derived directly from the underlying structural CHM data, the two methods naturally yield similar results once a pile is successfully detected. Since both algorithms operate on the same input data to generate measurements for a given location, major differences in quantification accuracy are only expected if there are significant disparities in detection performance. Our detection accuracy evaluation confirmed that both methods performed similarly, and as a result, they produced ~~nearly~~ identical representations of physical pile attributes.

### Stand-level Aggregation

Let’s summarize the measurement values of the predictions (true positive and false positive) and the ground truth data (true positive and false negative) over the entire stand (this is similar to a basal area comparison in a forest inventory). Summarizing the predicted and ground truth pile height and diameter form measurements for all instances across the entire study area, regardless of whether individual piles were successfully matched between datasets, for comparison provides insight into the method’s aggregated performance in predicting total pile size in an area. Such totals are often required for administrative needs like submitting burn permits which do not typically focus on individual pile quantification differences.

```{r}
# sum_df_temp <- 
stand_agg_fn <- function(
    df
    ,which_comp = "field" # or "gt"
) {
  df %>% 
  dplyr::ungroup() %>% 
  dplyr::select(-c(pred_id)) %>% 
  dplyr::summarise(
    dplyr::across(
      .cols = tidyselect::starts_with( paste0(which_comp,"_") ) | tidyselect::starts_with("pred_")
      , ~sum(.x,na.rm=T)
    )
  ) %>% 
  tidyr::pivot_longer(
    cols = dplyr::everything()
    , names_to = "metric"
    , values_to = "value"
  ) %>% 
  dplyr::mutate(
    which_data = dplyr::case_when(
        stringr::str_starts(metric,"field_") ~ "field"
        , stringr::str_starts(metric,"gt_") ~ "image-annotated"
        , stringr::str_starts(metric,"pred_") ~ "prediction"
        , T ~ "error"
      ) %>% 
      ordered()
    , pile_metric = metric %>% 
      stringr::str_remove("(_rmse|_rrmse|_mean|_mape)$") %>% 
      stringr::str_extract("(allom_volume|volume|area|height|diameter)") %>% 
      factor(
        ordered = T
        , levels = c(
          "height"
          , "diameter"
          , "area"
          , "volume"
        )
        , labels = c(
          "Height (m)"
          , "Diameter (m)"
          , "Area (m2)"
          , "Volume (m3)"
        )
      )
  ) %>% 
  dplyr::group_by(pile_metric) %>% 
  dplyr::arrange(pile_metric,which_data) %>% 
  dplyr::mutate(
    pct_diff = (value-dplyr::lag(value))/dplyr::lag(value) 
  ) %>% 
  dplyr::ungroup()
}
# do it
sum_df_temp <- 
  dplyr::bind_rows(
    dbscan_gt_pred_match[["psinf"]] %>% stand_agg_fn() %>% dplyr::mutate(method = "dbscan")
    , watershed_gt_pred_match[["psinf"]] %>% stand_agg_fn() %>% dplyr::mutate(method = "watershed")
  ) %>% 
  dplyr::filter(
    !stringr::str_detect(metric,"volume")
    , !stringr::str_detect(metric,"area")
  )
# sum_df_temp %>% dplyr::glimpse()
```

plot the aggregated, stand-level height and diameter comparison between field-measured and predicted piles

```{r}
# plot it
sum_df_temp %>% 
  dplyr::ungroup() %>% 
  dplyr::mutate(
    stand_id=1
    , lab = paste0(
      scales::comma(value,accuracy=0.1)
      , dplyr::case_when(
        is.na(pct_diff) ~ ""
        , T ~ paste0(
          "\n"
          , ifelse(pct_diff<0,"-","+")
          ,scales::percent(abs(pct_diff),accuracy=0.1)
        )
      )
    )
  ) %>% 
  ggplot2::ggplot(
    mapping = ggplot2::aes(
      x = which_data
      , y = value
      , label = lab
      , group = stand_id
    )
  ) +
  ggplot2::geom_line(key_glyph = "point", alpha = 0.7, color = "gray", lwd = 1.1) +
  ggplot2::geom_col(mapping = ggplot2::aes(fill = which_data), alpha = 1, width = 0.4) +
  harrypotter::scale_color_hp_d(option = "lunalovegood") +
  harrypotter::scale_fill_hp_d(option = "lunalovegood") +
  ggplot2::geom_text(
    vjust = -0.25
  ) +
  ggplot2::facet_grid(
    rows = dplyr::vars(pile_metric)
    , cols = dplyr::vars(method)
    , scales = "free_y", axes = "all_x"
    , switch = "y"
  ) +
  ggplot2::scale_y_continuous(labels = scales::comma, expand = ggplot2::expansion(mult = c(0,.3)), breaks = NULL) +
  ggplot2::labs(
    x = "", y = ""
    , subtitle = "Comparison of aggregated measurements at the PSINF site"
  ) +
  ggplot2::theme_light() +
  ggplot2::theme(
    legend.position = "none"
    , axis.text.x = ggplot2::element_text(size = 11, color = "black", face = "bold")
    , strip.text = ggplot2::element_text(size = 11, color = "black", face = "bold")
    , panel.grid = ggplot2::element_blank()
  ) 
  
```

table the aggregated, stand-level height and diameter comparison between field-measured and predicted piles

```{r}
sum_df_temp %>% 
  dplyr::mutate(
    pile_metric=stringr::word(pile_metric)
    , value = scales::comma(value,accuracy=0.1)
    , pct_diff = scales::percent(pct_diff,accuracy=0.1)
  ) %>% 
  tidyr::pivot_wider(
    id_cols = method
    , values_from = c(value,pct_diff)
    , names_from = c(pile_metric,which_data)
  ) %>% 
  dplyr::select(dplyr::where(~ !all(is.na(.x)))) %>% 
  dplyr::rename_with(
    .cols = dplyr::everything()
    , .fn = ~ dplyr::case_when(
      stringr::str_starts(.x,"value_") ~ stringr::str_remove(.x,"^value_") %>% stringr::str_c("_value")
      , stringr::str_starts(.x,"pct_diff_") ~ stringr::str_remove(.x,"^pct_diff_") %>% stringr::str_c("_zzpct_diff")
      , T ~ .x
    )
  ) %>% 
  dplyr::select(order(colnames(.))) %>% 
  dplyr::mutate(site = all_stand_boundary %>% dplyr::filter(site_data_lab=="psinf") %>% dplyr::pull(site)) %>% 
  dplyr::relocate(site,method) %>% 
  dplyr::arrange(site,method) %>% 
  kableExtra::kbl(
    caption = "Comparison of aggregated measurements at the PSINF site"
    , col.names = c(
      "site", "method"
      , rep(c("Field","Predicted","Pct Diff"), times = 2)
    )
    , escape = F
    # , digits = 2
  ) %>% 
  kableExtra::kable_styling(font_size = 11.5) %>% 
  kableExtra::add_header_above(c(
    " "=2
    # , "Detection" = 3
    # , "Area" = 3
    , "Diameter (m)" = 3
    , "Height (m)" = 3
  )) %>% 
  kableExtra::column_spec(seq(2,8,by=3), border_right = TRUE, include_thead = TRUE) %>% 
  # kableExtra::column_spec(
  #   column = 3:9
  #   , extra_css = "font-size: 10px;"
  #   , include_thead = T
  # ) %>% 
  kableExtra::collapse_rows(columns = 1, valign = "top")
```

## Area Accuracy

We could also evaluate quantification accuracy using pile areas based on the image annotations, though these are less presumptive than the "gold standard" field measurements. These annotations were occasionally limited by the difficulty of pinpointing exact pile boundaries, even when using high-resolution RGB data. Despite the potential for human error in the digitizing process, these area measurements provide additional validation data that is available across all four study sites.

```{r}
  ########################## adj this if want lots of cols
df_temp %>% 
  dplyr::select(
    !tidyselect::contains("_height_")
    & !tidyselect::contains("_diameter_")
    & !tidyselect::ends_with("_trees")
    # & !tidyselect::ends_with("_n")
    & !tidyselect::ends_with("_rate")
  ) %>% 
  dplyr::select(
    -c(recall,precision,f_score)
  ) %>% 
  ########################## adj this if want lots of cols
  # dplyr::glimpse()
  dplyr::relocate(site,method,tp_n) %>% 
  dplyr::arrange(site,method) %>% 
  kableExtra::kbl(
    caption = "Quantification Accuracy"
    , col.names = c(
      "site", "method", "TP predictions"
      , rep(c("ME","RMSE","MAPE"), times = 1)
    )
    , escape = F
    # , digits = 2
  ) %>% 
  kableExtra::kable_styling(font_size = 11.5) %>% 
  kableExtra::add_header_above(c(
    " "=3
    # , "Detection" = 3
    # , "Area" = 3
    , "Area (m<sup>2</sup>)" = 3
    
  ), escape = F) %>% 
  kableExtra::column_spec(seq(3,6,by=3), border_right = TRUE, include_thead = TRUE) %>% 
  # kableExtra::column_spec(
  #   column = 3:9
  #   , extra_css = "font-size: 10px;"
  #   , include_thead = T
  # ) %>% 
  kableExtra::collapse_rows(columns = 1, valign = "top")
```

These results further confirm that the two segmentation methods yield similar quantification accuracies for pile area, mirroring the patterns observed for height and diameter. While the absolute area accuracy naturally varies across study sites according to the average pile size, the MAPE remains decently low, ranging between `r scales::percent(min(agg_ground_truth_match_ans$pct_diff_area_m2_mape),accuracy = 0.1)` and `r scales::percent(max(agg_ground_truth_match_ans$pct_diff_area_m2_mape),accuracy = 0.1)` across all locations. These metrics suggest that both DBSCAN and Watershed are capable of delineating pile boundaries with acceptable precision.

### Stand-level Aggregation

Let’s summarize the measurement values of the predictions (true positive and false positive) and the ground truth data (true positive and false negative) over the entire stand (this is similar to a basal area comparison in a forest inventory). Summarizing the predicted and ground truth pile height and diameter form measurements for all instances across the entire study area, regardless of whether individual piles were successfully matched between datasets, for comparison provides insight into the method’s aggregated performance in predicting total pile size in an area. Such totals are often required for administrative needs like submitting burn permits which do not typically focus on individual pile quantification differences.

```{r}
# do it
sum_df_temp <-
  all_stand_boundary$site_data_lab %>% 
  purrr::map(
    \(x)
    dplyr::bind_rows(
      dbscan_gt_pred_match[[x]] %>% 
        stand_agg_fn(which_comp = "gt") %>% 
        dplyr::mutate(
          method = "dbscan"
          , site = all_stand_boundary %>% dplyr::filter(site_data_lab==x) %>% dplyr::pull(site)
        )
      , watershed_gt_pred_match[[x]] %>% 
        stand_agg_fn(which_comp = "gt") %>% 
        dplyr::mutate(
          method = "watershed"
          , site = all_stand_boundary %>% dplyr::filter(site_data_lab==x) %>% dplyr::pull(site)
        )
    ) %>% 
    dplyr::filter(
      stringr::str_detect(metric,"area")
    ) 
  ) %>% 
  dplyr::bind_rows()
  
# sum_df_temp %>% dplyr::glimpse()
```

plot the aggregated, stand-level height and diameter comparison between field-measured and predicted piles

```{r}
# plot it
sum_df_temp %>% 
  dplyr::ungroup() %>% 
  dplyr::mutate(
    stand_id=1
    , lab = paste0(
      scales::comma(value,accuracy=0.1)
      , dplyr::case_when(
        is.na(pct_diff) ~ ""
        , T ~ paste0(
          "\n"
          , ifelse(pct_diff<0,"-","+")
          ,scales::percent(abs(pct_diff),accuracy=0.1)
        )
      )
    )
  ) %>% 
  ggplot2::ggplot(
    mapping = ggplot2::aes(
      x = which_data
      , y = value
      , label = lab
      , group = stand_id
    )
  ) +
  ggplot2::geom_line(key_glyph = "point", alpha = 0.7, color = "gray", lwd = 1.1) +
  ggplot2::geom_col(mapping = ggplot2::aes(fill = which_data), alpha = 1, width = 0.4) +
  harrypotter::scale_color_hp_d(option = "lunalovegood") +
  harrypotter::scale_fill_hp_d(option = "lunalovegood") +
  ggplot2::geom_text(
    vjust = -0.25
  ) +
  ggplot2::facet_grid(
    rows = dplyr::vars(site)
    , cols = dplyr::vars(method)
    , scales = "free_y", axes = "all_x"
    , switch = "y"
  ) +
  ggplot2::scale_y_continuous(labels = scales::comma, expand = ggplot2::expansion(mult = c(0,.3)), breaks = NULL) +
  ggplot2::labs(
    x = "", y = ""
    , subtitle = 
      latex2exp::TeX("Comparison of aggregated pile Area ($m^2$) measurements for all sites")
  ) +
  ggplot2::theme_light() +
  ggplot2::theme(
    legend.position = "none"
    , axis.text.x = ggplot2::element_text(size = 11, color = "black", face = "bold")
    , strip.text = ggplot2::element_text(size = 11, color = "black", face = "bold")
    , panel.grid = ggplot2::element_blank()
  ) 
  
```

table the aggregated, stand-level height and diameter comparison between field-measured and predicted piles

```{r}
sum_df_temp %>% 
  dplyr::mutate(
    pile_metric=stringr::word(pile_metric)
    , value = scales::comma(value,accuracy=0.1)
    , pct_diff = scales::percent(pct_diff,accuracy=0.1)
  ) %>% 
  tidyr::pivot_wider(
    id_cols = c(site,method)
    , values_from = c(value,pct_diff)
    , names_from = c(pile_metric,which_data)
  ) %>% 
  dplyr::select(dplyr::where(~ !all(is.na(.x)))) %>% 
  dplyr::rename_with(
    .cols = dplyr::everything()
    , .fn = ~ dplyr::case_when(
      stringr::str_starts(.x,"value_") ~ stringr::str_remove(.x,"^value_") %>% stringr::str_c("_value")
      , stringr::str_starts(.x,"pct_diff_") ~ stringr::str_remove(.x,"^pct_diff_") %>% stringr::str_c("_zzpct_diff")
      , T ~ .x
    )
  ) %>% 
  dplyr::select(order(colnames(.))) %>% 
  dplyr::relocate(site,method) %>% 
  # dplyr::glimpse()
  dplyr::arrange(site,method) %>% 
  kableExtra::kbl(
    caption = "Comparison of aggregated area measurements for all sites"
    , col.names = c(
      "site", "method"
      , rep(c("Image-annotated","Predicted","Pct Diff"), times = 1)
    )
    , escape = F
    # , digits = 2
  ) %>% 
  kableExtra::kable_styling(font_size = 11.5) %>% 
  kableExtra::add_header_above(c(
    " "=2
    # , "Detection" = 3
    # , "Area" = 3
    , "Area (m<sup>2</sup>)" = 3
  ),escape = F) %>% 
  kableExtra::column_spec(seq(2,5,by=3), border_right = TRUE, include_thead = TRUE) %>%
  # kableExtra::column_spec(
  #   column = 3:9
  #   , extra_css = "font-size: 10px;"
  #   , include_thead = T
  # ) %>% 
  kableExtra::collapse_rows(columns = 1, valign = "top")
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

## Volume Comparison

We excluded quantification accuracy metrics for derived volume because the resulting value would not constitute a true "error". Comparing our predicted volume to a volume that was *not* directly measured, but instead calculated using a geometric assumption (like assuming a perfectly circular base and paraboloid shape) would be inappropriate. This is because any resulting difference between the prediction and the ground truth would be a blend of three inseparable factors: the error of the remote-sensing prediction method, the error in the direct field measurements (diameter/height), and the error introduced by the geometric shape assumption. Reporting such combined errors would be misleading, as it would be impossible to isolate the true performance of our remote-sensing method alone.

Instead, data involving derived values of volume based on field measurements and a shape assumption and its comparison to our irregularly shaped CHM-derived volume will be treated simply as data points for insight into the differences. Using geometric shape assumptions for estimating pile volume is the standard practice when implementing prescriptions or preparing for slash pile burning ([Hardy 1996](https://permanent.fdlp.gov/gpo45282/index.htm); [Long & Boston 2014](https://doi.org/10.5849/forsci.13-501)). This comparison will help us understand the discrepancy between our irregularly shaped CHM-derived volume and the volume calculated assuming a perfectly circular base and paraboloid shape with field-measured height and diameter. This approach will still provide valuable context about the impact of the perfectly circular base and paraboloid geometric assumptions without falsely attributing the error of the simplified model to the remote-sensing method itself.

let's do that now

* **field-measured piles** 
  - **volume** assumes a paraboloid shape, with volume calculated using the field-measured diameter (as the width) and height. we'll refer to this as "Allometric Field Volume" to indicate the field measurement is derived using a shape assumption.
* **predicted piles** 
  - **volume** calculated from the elevation profile of the irregular predicted pile footprint, without assuming a specific geometric shape. we'll refer to this as "Predicted Volume" to indicate the predicted measurement is from our CHM-based detection methodology
  
We would generally expect that the allometric field volume is larger than the predicted volume because the allometric calculation assumes a perfectly regular geometric shape (circular base and paraboloid) based on maximum field dimensions (height and diameter). this process effectively encloses the actual, irregular pile form within a simplified geometric dome which inherently neglects and sits above the actual irregularities and voids in the pile structure, likely leading to an overestimation of the volume.
  
we already added volume measurements to the TP matches for both the ground truth and predicted piles, summary of that data

```{r}
dbscan_gt_pred_match[["psinf"]] %>% 
  dplyr::filter(match_grp=="true positive") %>% 
  dplyr::select(field_volume_m3, pred_volume_m3) %>% 
  summary()
```

those don't really look like they match up well...let's explore

```{r}
dbscan_gt_pred_match[["psinf"]] %>% 
  dplyr::filter(match_grp=="true positive") %>% 
  dplyr::mutate(diff_volume_m3 = field_volume_m3 - pred_volume_m3) %>% 
  ggplot2::ggplot(mapping = ggplot2::aes(y = field_volume_m3, x = pred_volume_m3)) +
  ggplot2::geom_abline(lwd = 1.5) +
  # ggplot2::geom_point(ggplot2::aes(color = diff_volume_m3)) +
  ggplot2::geom_point(color = "navy") +
  ggplot2::geom_smooth(method = "lm", se=F, color = "tomato", linetype = "dashed") +
  ggplot2::scale_color_viridis_c(option = "mako", direction = -1, alpha = 0.8) +
  ggplot2::scale_x_continuous(limits = c(0, max( max(dbscan_gt_pred_match[["psinf"]]$pred_volume_m3,na.rm=T), max(dbscan_gt_pred_match[["psinf"]]$field_volume_m3,na.rm=T) ) )) +
  ggplot2::scale_y_continuous(limits = c(0, max( max(dbscan_gt_pred_match[["psinf"]]$pred_volume_m3,na.rm=T), max(dbscan_gt_pred_match[["psinf"]]$field_volume_m3,na.rm=T) ) )) +
  ggplot2::labs(
    y = latex2exp::TeX("allometric field volume $m^3$")
    , x = latex2exp::TeX("predicted volume $m^3$")
    # , color = "image-field\ndiameter diff."
    , subtitle = latex2exp::TeX("bulk volume ($m^3$) comparison")
  ) +
  ggplot2::theme_light()
```

this is exactly what we expected: for true positive matches, there is a clear systematic difference with the plot showing that the volume calculated using the idealized, regular shape assumption (allometric field volume) is consistently larger than the predicted volume derived from the CHM

let's check these using `lm()`

```{r}
lm_temp <- lm(field_volume_m3 ~ pred_volume_m3, data = dbscan_gt_pred_match[["psinf"]] %>% dplyr::filter(match_grp=="true positive"))
summary(lm_temp)
```

These linear model results (intercept = `r scales::comma(lm_temp$coefficients[1], accuracy = 0.01)`, slope = `r scales::comma(lm_temp$coefficients[2], accuracy = 0.01)`) indicate a strong proportional bias that significantly increases with pile size. The high slope (`r scales::comma(lm_temp$coefficients[2], accuracy = 0.01)`) coupled with the negative intercept (`r scales::comma(lm_temp$coefficients[1], accuracy = 0.01)`) indicate that the volume difference is not a simple constant offset (e.g. slope of ~1.0 and intercept of >0 if our hypothesis of consistently higher allometric field volume is true), but rather a scaling issue that is driven by the largest piles. The much larger allometric field volume estimates relative to the CHM-predicted volumes for the largest piles exert a strong influence on the predicted form of the liner model, pulling the slope steeply upward and forcing the intercept below zero as a mathematical artifact. Despite the predicted negative intercept, visual inspection of the data shows that most allometric field volumes are larger than the CHM-predicted volumes, even for smaller piles. The slope value indicates that for every 1 m^3^ increase in predicted volume, the allometric field volume increases by nearly `r scales::comma(lm_temp$coefficients[2], accuracy = 0.01)` m^3^. This data suggests that the geometric assumptions of the allometric model potentially introduce substantial scaling error which may limit its reliability (especially for larger piles) for accurately estimating the volume of real-world piles which have heterogeneous footprints and elevation profiles.

before we compare the volume measurements in aggregate, let's look at the distributions

```{r}
vol_df_temp <- 
  dbscan_gt_pred_match[["psinf"]] %>% 
  dplyr::filter(match_grp=="true positive") %>% 
  dplyr::select(pile_id,field_volume_m3,pred_volume_m3) %>% 
  tidyr::pivot_longer(cols = -c(pile_id)) %>% 
  dplyr::mutate(
    name = factor(
      name
      , ordered = T
      , levels = c("field_volume_m3","pred_volume_m3")
      , labels = c(
        "allometric field volume"
        , "predicted volume"
      )
    )
  ) 
# plot dist
vol_df_temp %>% 
  ggplot2::ggplot(mapping = ggplot2::aes(x = value, color = name, fill = name)) +
  ggplot2::geom_density(mapping = ggplot2::aes(y=ggplot2::after_stat(scaled)), alpha = 0.7) +
  harrypotter::scale_color_hp_d(option = "lunalovegood") +
  harrypotter::scale_fill_hp_d(option = "lunalovegood") +
  ggplot2::scale_y_continuous(NULL,breaks=NULL) +
  ggplot2::labs(
    color="",fill="",x=latex2exp::TeX("volume $m^3$")
    , subtitle = latex2exp::TeX("bulk volume ($m^3$) comparison of distributions")
  ) +
  ggplot2::theme_light() +
  ggplot2::theme(
    legend.position = "top"
  )
```

slope plots are neat too

```{r}
vol_df_temp %>% 
  ggplot2::ggplot(
    mapping = ggplot2::aes(x = name, y = value, group = pile_id)
  ) +
  ggplot2::geom_line(key_glyph = "point", alpha = 0.7, color = "gray", lwd = 1.1) +
  ggplot2::geom_point(mapping = ggplot2::aes(color = name), alpha = 0.7, size = 2.5) +
  harrypotter::scale_color_hp_d(option = "lunalovegood") +
  ggplot2::labs(
    color=""
    , y = latex2exp::TeX("volume $m^3$")
    , x = ""
    , subtitle = latex2exp::TeX("bulk volume ($m^3$) comparison at the pile level")
  ) +
  ggplot2::theme_light() +
  ggplot2::theme(
    legend.position = "none"
    , axis.title = ggplot2::element_text(size = 10)
    , axis.text = ggplot2::element_text(size = 10)
  )
```

what if we only look at the smaller piles?

```{r}
vol_df_temp %>% 
  dplyr::ungroup() %>% 
  dplyr::mutate(x = value < quantile(vol_df_temp$value, probs = 0.90)) %>%
  dplyr::group_by(pile_id) %>% 
  dplyr::filter(
    max(x) == 1
  ) %>% 
  ggplot2::ggplot(
    mapping = ggplot2::aes(x = name, y = value, group = pile_id)
  ) +
  ggplot2::geom_line(key_glyph = "point", alpha = 0.7, color = "gray", lwd = 1.1) +
  ggplot2::geom_point(mapping = ggplot2::aes(color = name), alpha = 0.7, size = 2.5) +
  harrypotter::scale_color_hp_d(option = "lunalovegood") +
  ggplot2::labs(
    color=""
    , y = latex2exp::TeX("volume $m^3$")
    , x = ""
    , subtitle = latex2exp::TeX("bulk volume ($m^3$) comparison at the pile level for the smaller piles")
  ) +
  ggplot2::theme_light() +
  ggplot2::theme(
    legend.position = "none"
    , axis.title = ggplot2::element_text(size = 10)
    , axis.text = ggplot2::element_text(size = 10)
  )
```

let's compare aggregated volume measurements for the true positive matches

**Mean Difference (MD):** 
$$\text{MD} = \frac{1}{N} \sum_{i=1}^{N} (\text{Allometric Volume}_i - \text{Predicted Volume}_i)$$

**Percent Mean Difference:** 
$$\%\text{MD} = \frac{\text{MD}}{\text{Mean}(\text{Predicted Volume})} \times 100$$

```{r}
vol_agg_df_temp <- 
  dbscan_gt_pred_match[["psinf"]] %>% 
  dplyr::filter(match_grp=="true positive") %>% 
  dplyr::ungroup() %>% 
  dplyr::summarise(
    mean_diff = mean(field_volume_m3-pred_volume_m3)
    , sd_diff = sd(field_volume_m3-pred_volume_m3)
    , mean_field_volume_m3 = mean(field_volume_m3,na.rm = T)
    , mean_pred_volume_m3 = mean(pred_volume_m3,na.rm = T)
  ) %>% 
  dplyr::mutate(
    pct_mean_diff = mean_diff/mean_pred_volume_m3
  )
```

what did we get?

```{r}
vol_agg_df_temp %>% 
  tidyr::pivot_longer(dplyr::everything()) %>% 
  dplyr::mutate(
    value = 
      dplyr::case_when(
        stringr::str_starts(name, "pct_") ~ scales::percent(value, accuracy = 0.1)
        , T ~ scales::comma(value, accuracy = 0.1)
      )
  ) %>% 
  kableExtra::kbl(
    caption = "comparison of aggregated allometric field volume and predicted volume"
    , col.names = c("metric", "value")
  ) %>% 
  kableExtra::kable_styling()
```

we'll dig into the MD shortly but before we move on let's focus on the percent mean difference. We calcualted a %MD of `r scales::percent(vol_agg_df_temp$pct_mean_diff, accuracy = 0.1)` which indicates a major systematic difference where the allometric field volume is, on average, `r scales::percent(vol_agg_df_temp$pct_mean_diff, accuracy = 0.1)` larger than our CHM-predicted volume. This large relative difference shows how much the geometric assumptions inflate the volume compared to the irregular volumes measured by our remote sensing-based method.

let's make a Bland-Altman plot to compare the two measurement methods. this plot uses the average of the two measurements (approximate size) on the x-axis and the difference (bias) between the two measurements on the y-axis

```{r}
dbscan_gt_pred_match[["psinf"]] %>% 
  dplyr::filter(match_grp=="true positive") %>%
  dplyr::ungroup() %>% 
  # calc needed metrics
  dplyr::mutate(
    mean_vol = (field_volume_m3+pred_volume_m3)/2
    , diff_vol = (field_volume_m3-pred_volume_m3) # match the order used in vol_agg_df_temp
    , scale_diff = ifelse(diff_vol < 0, -abs(diff_vol) / abs(min(diff_vol)), diff_vol / max(diff_vol))
  ) %>% 
  # ggplot() + geom_point(aes(x=diff_vol,y=0, color=scale_diff)) + scale_color_gradient2(mid = "gray", midpoint = 0, low = "red", high = "blue")
  # plot
  ggplot2::ggplot(
    mapping = ggplot2::aes(x = mean_vol, y = diff_vol)
  ) +
  ggplot2::geom_hline(yintercept = 0, color = "black", lwd = 1.2) +
  # mean difference (bias)
  ggplot2::geom_hline(
    yintercept = vol_agg_df_temp$mean_diff
    , linetype = "dashed", color = "blue", lwd = 1
  ) +
  # upper limit
  ggplot2::geom_hline(
    yintercept = vol_agg_df_temp$mean_diff+1.96*vol_agg_df_temp$sd_diff
    , linetype = "dotted", color = "red", lwd = 1
  ) +
  # lower limit
  ggplot2::geom_hline(
    yintercept = vol_agg_df_temp$mean_diff-1.96*vol_agg_df_temp$sd_diff
    , linetype = "dotted", color = "red", lwd = 1
  ) +
  # annotations
  ggplot2::annotate(
    "text"
    , x = Inf
    , y = vol_agg_df_temp$mean_diff
    , label = latex2exp::TeX(
      paste0(
        "mean difference (bias): "
        , scales::comma(vol_agg_df_temp$mean_diff, accuracy = 0.01)
        , " $m^3$"
      )
      , output = "character"
    )
    , vjust = -0.5
    , hjust = 1
    , color = "blue"
    , size = 4
    , parse = TRUE
  ) +
  ggplot2::annotate(
    "text"
    , x = Inf
    , y = vol_agg_df_temp$mean_diff+1.96*vol_agg_df_temp$sd_diff
    , label = latex2exp::TeX(
      paste0(
        "+1.96 SD: "
        , scales::comma(vol_agg_df_temp$mean_diff+1.96*vol_agg_df_temp$sd_diff, accuracy = 0.01)
        , " $m^3$"
      )
      , output = "character"
    )
    , vjust = -0.5
    , hjust = 1
    , color = "red"
    , size = 4
    , parse = TRUE
  ) +
  ggplot2::annotate(
    "text"
    , x = Inf
    , y = vol_agg_df_temp$mean_diff-1.96*vol_agg_df_temp$sd_diff
    , label = latex2exp::TeX(
      paste0(
        "-1.96 SD: "
        , scales::comma(vol_agg_df_temp$mean_diff-1.96*vol_agg_df_temp$sd_diff, accuracy = 0.01)
        , " $m^3$"
      )
      , output = "character"
    )
    , vjust = 1.5
    , hjust = 1
    , color = "red"
    , size = 4
    , parse = TRUE
  ) +
  # points
  ggplot2::geom_point(mapping = ggplot2::aes(color = scale_diff), size = 1.9, alpha = 0.8) +
  ggplot2::scale_color_steps2(mid = "gray", midpoint = 0) +
  ggplot2::labs(
    subtitle = "Bland-Altman plot: allometric field volume vs predicted volume"
    , x = latex2exp::TeX("mean volume ($m^3$)")
    , y = latex2exp::TeX("difference (allometric - predicted volume $m^3$)")
  ) +
  ggplot2::theme_light() +
  ggplot2::theme(legend.position = "none")
```

That's a lot of plotting to show that the mean difference is `r scales::comma(vol_agg_df_temp$mean_diff, accuracy = 0.01)` m^3^. Points falling outside the 95% interval on the plot are instances of significant disagreement between the two volume measurements for those specific data points. These outliers indicate that, for a particular pile, the difference between the allometric field volume and the predicted volume is unusually large, suggesting a potential failure in either the CHM segmentation process, the quality of the original field measurements, the geometric shape assumption, or a combination thereof. We should investigate these extreme disagreements further to see what is happening

before we do that, let's use a paired t-test to determine if the mean difference (MD) between the allometric field volume and the predicted volume is statistically significant (i.e. significantly different from zero)

```{r}
# is the mean difference between the two volumes significantly different from zero
ttest_temp <- t.test(
  dbscan_gt_pred_match[["psinf"]] %>% 
    dplyr::filter(match_grp == "true positive") %>% 
    dplyr::pull(field_volume_m3)
  , dbscan_gt_pred_match[["psinf"]] %>% 
    dplyr::filter(match_grp == "true positive") %>% 
    dplyr::pull(pred_volume_m3)
  , paired = TRUE
)
ttest_temp
```

that's neat, the test gave us the same mean difference (MD) of `r scales::comma(vol_agg_df_temp$mean_diff, accuracy = 0.01)` m^3^ that we calculated above. also, the p-value of `r scales::comma(ttest_temp$p.value, accuracy = 0.00001)` is less than 0.05, meaning we should reject the null hypothesis that the true mean difference is zero. this confirms that the systematic difference (or bias) we observed where allometric volume is larger than our predicted volume is statistically significant and not due to random chance.

### Extreme Volume Disagreements

let's investigate the extreme disagreements further to see what is happening 

```{r}
bad_vol_df_temp <- 
  dbscan_gt_pred_match[["psinf"]] %>% 
  dplyr::filter(match_grp=="true positive") %>%
  dplyr::ungroup() %>% 
  # calc needed metrics
  dplyr::mutate(
    diff_vol = (field_volume_m3-pred_volume_m3) # match the order used in vol_agg_df_temp
  ) %>% 
  dplyr::filter(
    diff_vol < (vol_agg_df_temp$mean_diff-1.96*vol_agg_df_temp$sd_diff)
    | diff_vol > (vol_agg_df_temp$mean_diff+1.96*vol_agg_df_temp$sd_diff)
  ) %>% 
  dplyr::left_join(
    slash_piles_polys[["psinf"]] %>% 
      sf::st_drop_geometry() %>% 
      dplyr::select(pile_id, comment) %>% 
      dplyr::rename(pile_type = comment)
    , by = "pile_id"
  )
# what are the differences?
bad_vol_df_temp %>% 
  dplyr::select(
    pile_id, pile_type
    , field_height_m, pred_height_m, diff_field_height_m
    , field_diameter_m, pred_diameter_m, diff_field_diameter_m
    , field_volume_m3, pred_volume_m3
  ) %>% 
  dplyr::mutate(
    dplyr::across(
      .cols = -c(pile_id,pile_type)
      , .fns = ~ scales::comma(.x,accuracy=0.01)
    )
  ) %>% 
  kableExtra::kbl(
    caption = "Volume measurement outliers: comparison of ground truth and predicted piles"
    # , col.names = c("metric", "value")
  ) %>% 
  kableExtra::kable_styling(font_size = 9.8)
```

All of the extreme volume discrepancies at the PSINF site occur for mechanical piles, where field-measured heights exceed the predicted, CHM-derived heights. One possible cause of this height discrepancy is that the `max_ht_m` parameter was set too low to capture the upper extent of these taller structures. If this is the case, then the predicted height would be right at the maximum height allowed by `max_ht_m`. However, we set the `max_ht_m` parameter to `r all_stand_boundary %>% dplyr::filter(site_data_lab=="psinf") %>% dplyr::pull(max_ht_m) %>% scales::comma(accuracy = 0.1)` m and the maximum predicted height of these piles was `r max(bad_vol_df_temp$pred_height_m) %>% scales::comma(accuracy=0.1)` m which means that it is not likely that the height-filtered CHM removed the top of the pile from the unfiltered CHM.

Instead, the under-prediction appears to stem from artifacts in height normalization during point cloud processing. If we go back to look at [the DTM of this site](#ptcld_process_psinf) we can see slight vertical variations within the pile footprints, suggesting that the ground classification algorithm incorrectly identified the lower portions of these larger piles as terrain. Because the DTM was incorrectly inflated within the pile footprint the height-normalized CHM slightly underestimates the true height of the piles.

```{r, fig.height=9.2}
bad_vol_df_temp %>% 
  dplyr::select(
    pile_id
    , field_height_m, pred_height_m
    , field_diameter_m, pred_diameter_m
    , field_volume_m3, pred_volume_m3
  ) %>% 
  tidyr::pivot_longer(
    cols = -c(pile_id)
    , names_to = "metric"
    , values_to = "value"
  ) %>% 
  dplyr::mutate(
    which_data = dplyr::case_when(
        stringr::str_starts(metric,"field_") ~ "field"
        , stringr::str_starts(metric,"pred_") ~ "prediction"
        , T ~ "error"
      ) %>% 
      ordered()
    , pile_metric = metric %>% 
      stringr::str_remove("(_rmse|_rrmse|_mean|_mape)$") %>% 
      stringr::str_extract("(paraboloid_volume|volume|area|height|diameter)") %>% 
      factor(
        ordered = T
        , levels = c(
          "volume"
          , "area"
          , "height"
          , "diameter"
        )
        , labels = c(
          "Volume (m3)"
          , "Area (m2)"
          , "Height (m)"
          , "Diameter (m)"
        )
      )
  ) %>% 
  ggplot2::ggplot(
    mapping = ggplot2::aes(x = which_data, y = value, label = scales::comma(value,accuracy=0.1), group = pile_id)
  ) +
  ggplot2::geom_line(key_glyph = "point", alpha = 0.7, color = "gray", lwd = 1.1) +
  ggplot2::geom_point(mapping = ggplot2::aes(color = which_data), alpha = 0.8, size = 2.5) +
  ggplot2::scale_color_manual(values = c("cyan","magenta")) +
  ggplot2::geom_text(
    vjust = -0.25
    , show.legend = FALSE
  ) +
  ggplot2::facet_grid(rows = dplyr::vars(pile_metric), scales = "free_y") +
  ggplot2::scale_y_continuous(labels = scales::comma, expand = ggplot2::expansion(mult = c(0.05,.32))) +
  ggplot2::labs(
    x = "", y = "", color = ""
    , subtitle = "Volume measurement outliers: comparison of measurements"
  ) +
  ggplot2::theme_light() +
  ggplot2::theme(
    legend.position = "none"
    , strip.text = ggplot2::element_text(size = 11, color = "black", face = "bold")
  ) 
```

RGB with the predicted piles (magenta) and the ground-truth piles (cyan) overlaid with the CHM

```{r, fig.height=10.5, fig.width=8.5, results=F, fig.show='asis'}
# cloud2raster_ans$chm_rast %>% 
#   terra::clamp(upper = structural_params_settings$max_ht_m, lower = 0, values = F) %>% 
#   terra::plot()
# bad_vol_df_temp %>% dplyr::glimpse()
# plot RGB + CHM
# plot RGB
plts_temp <-
  1:nrow(bad_vol_df_temp) %>% 
  # sample(1) %>% 
  purrr::map(function(x){
    dta <- bad_vol_df_temp %>% dplyr::slice(x)
    gt <- slash_piles_polys[["psinf"]] %>% dplyr::filter(pile_id==dta$pile_id)
    pr <- dbscan_spectral_preds[["psinf"]] %>% dplyr::filter(pred_id==dta$pred_id)
    #plt
    ortho_plt_fn(
      rgb_rast = rgb_rast[["psinf"]]
      , stand = gt
      , add_stand = F
      , buffer = 7
    ) +
      ggnewscale::new_scale_fill() +
      ggplot2::geom_tile(
        data = chm_rast[["psinf"]] %>% 
          terra::crop(
            sf::st_union(gt,pr) %>% 
              sf::st_transform(terra::crs(chm_rast[["psinf"]])) %>% 
              terra::vect()
            , mask = T
          ) %>% 
          terra::as.data.frame(xy=T) %>% 
          dplyr::rename(f=3)
        , mapping = ggplot2::aes(x=x,y=y,fill=f)
        , alpha = 0.5
        , inherit.aes = F
        , show.legend = T
      ) +
      ggplot2::scale_fill_viridis_c(
        option = "plasma", na.value = "gray",name = "CHM (m)"
        , limits = c(0,all_stand_boundary %>% dplyr::filter(site_data_lab=="psinf") %>% dplyr::pull(max_ht_m))
      ) +
      ggplot2::geom_sf(data = gt, fill = NA, color = "cyan", lwd = 0.6) +
      ggplot2::geom_sf(data = pr, fill = NA, color = "magenta", lwd = 0.5) +
      ggplot2::labs(
        subtitle = paste0(
          "Fld ht: ", round(dta$field_height_m,1)
          , " | Pred ht: ", round(dta$pred_height_m,1)
          , "\nFld dia: ", round(dta$field_diameter_m,1)
          , " | Pred dia: ", round(dta$pred_diameter_m,1)
        )
      ) +
      ggplot2::theme(
        legend.position = "bottom"
        , legend.text = ggplot2::element_text(size = 8)
        , legend.title = ggplot2::element_text(size = 8)
      )
  })
# plts_temp
# combine
patchwork::wrap_plots(
  plts_temp
  , ncol = 3
  , guides = "collect"
) +
patchwork::plot_annotation(
  theme = ggplot2::theme(
    legend.position = "bottom"
    , legend.text = ggplot2::element_text(size = 8)
    , legend.title = ggplot2::element_text(size = 8)
    , legend.margin = ggplot2::margin(0,0,0,0)
  )
)
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

