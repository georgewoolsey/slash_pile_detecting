# Methodology Evaluation{#str_preds}

We are finally ready to make predictions using our proposed training-free, rules-based methodology for identifying slash piles from UAS data. To this point we have:

1. Provided a data overview: [here](#data_desc) and [here](#data_load)
2. [Processed the UAS point cloud](#ptcld_process)
3. [Demonstrated our geometry-based slash pile detection methodology](#geom_detect)
4. [Demonstrated our spectral refinement (i.e. data fusion) methodology](#data_fusion)
5. and [Reviewed how we will evaluate our method](#meth_eval)

In this section, we'll evaluate the effectiveness of the proposed geometric, rules-based methodology by assessing its performance using structural data alone across the four study sites. This analysis assumes no spectral information is available and focuses exclusively on identifying candidate slash piles based on physical properties. While the subsequent integration of spectral data in our data fusion approach allows for less restrictive structural settings, the absence of spectral filtering in the present analysis necessitates stricter size and geometric thresholds to minimize false positive predictions.

## Size and Geometric Parameter Settings

Our geometric, rules-based methodology uses input CHM data and user-defined thresholds for size (height and area) and 2D pile footprint shape regularity (convexity and circularity). The expected height and area search range for slash piles should be based on the pile construction prescription and potentially adjusted based on a sample of field-measured values after treatment completion whether these are a sample of empirical measurements or rough estimates based on visual observation of pile construction outcomes post-treatment. These thresholds define the search space using the CHM data and refine candidate segments to yield final pile predictions.

Here, we review the pile construction prescription (if available) and supplemental visual observational information for each study site and set the size and geometric thresholds for our structural pile detection methodology.

The study site prescriptions can be reviewed [here](#data_desc)

### PSINF Mixed Conifer Site

While the silvicultural prescription provides no specific details regarding pile construction, the management objective to create a wildfire-resilient post-treatment structure suggests that piles were likely located in open spaces away from residual trees. This spacing might enhance the ability of our detection methodology by reducing structural interference from the canopy, regardless of the variations in pile size. Anecdotal feedback from post-treatment site walkthroughs further informs our structural parameters, indicating that hand-piles were generally well-constructed to facilitate efficient prescribed burning and approximately 1.5 m by 1.5 m (5 ft by 5 ft) in size. Mechanical piles at the landings maintained a roughly circular form but were significantly larger, with widths comparable to two or three work vehicles and a taller height than the vehicle.

### TRFO-BLM Pinyon-Juniper Site

The silvicultural prescription for the TRFO-BLM site includes exact pile construction minimum dimensions of 1.5 m (5 ft) in length, width, and height, which establishes an expected minimum pile area of approximately 2.3 square meters. While these guidelines focus on compact construction to facilitate consumption during burning, the lack of an explicit maximum size requires the use of anecdotal feedback to determine upper thresholds for our detection methodology. Site managers reported that piles were often larger than expected and "messy" (indicating more irregular footprints than expected). Despite the prescribed residual forest structure being characterized by open interspaces with uniform gaps between trees, the anecdotal observation that piles were frequently constructed too close to residual trees introduces a potential challenge for automated detection. This proximity may cause the structural and spectral signatures of the piles to merge with the surrounding canopy.

### BHEF Ponderosa Pine Site

While the silvicultural prescription for the BHEF site defines no specific pile construction parameters, the treatment resulted exclusively in mechanical piles located at landings without additional hand piles. Onsite observations indicated that these piles are uniformly massive and lack a standardized shape. For example, some piles were circular and piled high vertically while others were shorter with elongated oval footprints. We established detection thresholds by using familiar anchors to contextualize scale, such as the dimensions of our work truck. Ground-based cell phone images and an aerial UAS photo capturing the truck parked next to one of the largest piles confirmed that some piles reached the scale of a small-sized, one story American single-family home. We used these truck- and house-sized estimates to set high minimum area and height thresholds to isolate the piles from other features. Because these large dimensions may structurally resemble the residual tree groups, spectral information will likely improve the detection accuracy of our method by filtering out false positive predictions from the structural detection.

### ARNF Ponderosa Pine Site

While the silvicultural prescription for the ARNF site defines no specific pile construction parameters, it specifies that all residual waste was mechanically piled at landings for future prescribed burning. Onsite observations indicated that these mechanical piles are uniformly massive and generally circular. The piles were also compact and vertical in structure with limited horizontal sprawl, a construction form that will likely increase consumption efficiency during prescribed burning. Some landings contained clusters of two to five individual piles. To calibrate our detection methodology for these large-scale features, we used cell phone photos taken from the ground during site walkthroughs to compare the piles against a lifted Dodge Ram 2500 Mega Cab turbo diesel. By using this vehicle as a known physical anchor, we estimated that the piles were often at least 2-3 the truckâ€™s height of approximately 2.4 m (8 ft), with footprints significantly exceeding the 16.7 to 26.7 square meters of a standard parking space. These dimensional estimates allow us to set relatively large minimum area and height thresholds for our detection methodology to ensure the exclusion of smaller detected objects like trees or boulders since no small hand piles were expected.

### Paremeter Settings

| Parameter | PSINF Mixed Conifer Site | TRFO-BLM Pinyon-Juniper Site | BHEF Ponderosa Pine Site | ARNF Ponderosa Pine Site |
| :--- | :--- | :--- | :--- | :--- |
| `min_ht_m` | 1.2 (80% of min. hand pile) | 1.2 (80% of min. hand pile) | 2.0 (observation-based) | 2.4 (truck height) |
| `max_ht_m` | 5.0 (2x truck height) | 3.0 (2x hand pile height) | 6.0 (2.5x truck height) | 9.6 (4x truck height) |
| `min_area_m2` | 2.0 (90% of min. hand pile footprint) | 2.0 (90% of min. hand pile footprint) | 54.0 (2x parking space) | 54.0 (2x parking space) |
| `max_area_m2` | 54.0 (2x parking space) | 18.0 (8x hand pile footprint) | 486.0 (18x parking space) | 621.0 (23x parking space) |
| `min_convexity_ratio` | 0.5 (strict) | 0.15 (permissive) | 0.3 (moderate) | 0.25 (moderate) |
| `min_circularity_ratio` | 0.5 (strict) | 0.3 (moderate) | 0.0 (no circularity constraint) | 0.2 (moderate) |

let's table that so we have the information

```{r}
all_stand_boundary <- all_stand_boundary %>% 
  dplyr::left_join(
    dplyr::tibble(
      site = c("PSINF Mixed Conifer Site", "TRFO-BLM Pinyon-Juniper Site", "BHEF Ponderosa Pine Site", "ARNF Ponderosa Pine Site")
      , min_ht_m = c(1.2, 1.2, 2.0, 2.4)
      , max_ht_m = c(5.0, 3.0, 6.0, 9.6)
      , min_area_m2 = c(2.0, 2.0, 54.0, 54.0)
      , max_area_m2 = c(54.0, 18.0, 486.0, 621.0)
      , min_convexity_ratio = c(0.5, 0.15, 0.3, 0.25)
      , min_circularity_ratio = c(0.5, 0.3, 0.0, 0.2)
      , spectral_weight = c(5, 5, 6, 6)
    )  
    , by = "site"
  )
```

generate a `kableExtra` table

```{r}
all_stand_boundary %>% 
  sf::st_drop_geometry() %>% 
  dplyr::select(-c(
    tidyselect::starts_with("site_area")
    , site_data_lab
  )) %>% 
  tidyr::pivot_longer(cols=-site) %>% 
  tidyr::pivot_wider(names_from = site, values_from = value) %>% 
  dplyr::rename(parameter = name) %>% 
  # kable
  kableExtra::kbl(
    caption = "user-defined thresholds for size and expected pile shape regularity"
    , escape = F
    , digits = 1
  ) %>% 
  kableExtra::kable_styling()
```

let's organize our site boundary, ground truth, CHM, and RGB data into lists so we can programmatically iterate through all sites more efficiently

```{r, results=F, warning=F}
##########################################
# stand_boundary
##########################################
  # suffix
  suffix_temp <- "_stand_boundary"
  # convert to list of objects and remove the suffix from the name in the list
  stand_boundary <-
    all_stand_boundary$site_data_lab %>%
    paste0(suffix_temp) %>%
    base::mget(inherits = T) %>%
    purrr::set_names(~ str_remove(.x, suffix_temp))
  # names(stand_boundary)
  # dplyr::glimpse(stand_boundary)
  # remove
  all_stand_boundary$site_data_lab %>%
    paste0(suffix_temp) %>%
    purrr::map(\(x) remove(list = x,inherits = T))
##########################################
# slash_piles_polys
##########################################
  # suffix
  suffix_temp <- "_slash_piles_polys"
  # convert to list of objects and remove the suffix from the name in the list
  slash_piles_polys <-
    all_stand_boundary$site_data_lab %>%
    paste0(suffix_temp) %>%
    base::mget(inherits = T) %>%
    purrr::set_names(~ str_remove(.x, suffix_temp))
  # names(slash_piles_polys)
  # dplyr::glimpse(slash_piles_polys)
  # remove
  all_stand_boundary$site_data_lab %>%
    paste0(suffix_temp) %>%
    purrr::map(\(x) remove(list = x,inherits = T))
##########################################
# chm_rast
##########################################
  # suffix
  suffix_temp <- "_chm_rast"
  # convert to list of objects and remove the suffix from the name in the list
  chm_rast <-
    all_stand_boundary$site_data_lab %>%
    paste0(suffix_temp) %>%
    base::mget(inherits = T) %>%
    purrr::set_names(~ str_remove(.x, suffix_temp))
  # names(chm_rast)
  # dplyr::glimpse(chm_rast)
  # remove
  all_stand_boundary$site_data_lab %>%
    paste0(suffix_temp) %>%
    purrr::map(\(x) remove(list = x,inherits = T))
##########################################
# rgb_rast
##########################################
  # suffix
  suffix_temp <- "_rgb_rast"
  # convert to list of objects and remove the suffix from the name in the list
  rgb_rast <-
    all_stand_boundary$site_data_lab %>%
    paste0(suffix_temp) %>%
    base::mget(inherits = T) %>%
    purrr::set_names(~ str_remove(.x, suffix_temp))
  # names(rgb_rast)
  # dplyr::glimpse(rgb_rast)
  # remove
  all_stand_boundary$site_data_lab %>%
    paste0(suffix_temp) %>%
    purrr::map(\(x) remove(list = x,inherits = T))
```

## CHM-based Slash Pile Candidates

Our geometric, rules-based methodology uses input CHM data and user-defined thresholds for size (height and area) and 2D pile footprint shape regularity (convexity and circularity). We [defined a function](#slash_pile_detect_fn) to make the detection from the CHM easy given the parameters we reviewed above: `slash_pile_detect()`

```{r,include=FALSE,eval=FALSE}
x <- all_stand_boundary$site_data_lab[1]
terra::plot(chm_rast[[x]])
terra::plotRGB(rgb_rast[[x]])
terra::plot(stand_boundary[[x]] %>% sf::st_transform(terra::crs(rgb_rast[[x]])) %>% terra::vect(), add = T, border = "black", col = NA)
terra::plot(slash_piles_polys[[x]] %>% sf::st_transform(terra::crs(rgb_rast[[x]])) %>% terra::vect(), add = T, border = "cyan", col = NA, lwd = 1.2)
# terra::plot(dbscan_structural_preds[[x]] %>% sf::st_transform(terra::crs(rgb_rast[[x]])) %>% terra::vect(), add = T, border = "magenta", col = NA, lwd = 1.2)
remove(x)
gc()

xxx <- 
  all_stand_boundary$site_data_lab %>% 
  purrr::set_names() %>% 
  purrr::map(
    \(x)
    terra::clamp(
        chm_rast[[x]]
        , upper = all_stand_boundary %>% dplyr::filter(site_data_lab==x) %>% dplyr::pull(max_ht_m)
        , lower = 0, values = F
      )
    , .progress = T
  )
names(xxx)
xxx[["psinf"]] %>% terra::plot()
xxx[["pj"]] %>% terra::plot()
xxx[["arnf"]] %>% terra::plot()
xxx[["bhef"]] %>% terra::plot()
remove(xxx)
gc()
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

We'll get the predictions using both the DBSCAN and Watershed segmentation approaches. Review [this section](#seg_methods) for a refresher on how we use these methods

```{r, results=F, warning=FALSE}
##################################################
# map over slash_pile_detect for dbscan
##################################################
  # file.names to only run if not already done since it takes a while for all sites
  dir_temp <- "../data"
  if(!dir.exists(dir_temp)){dir.create(dir_temp,showWarnings = F)}
  nmsfx_temp <- "_dbscan_structural_preds.gpkg"
  if(
    !all(file.exists( file.path(dir_temp, paste0(all_stand_boundary$site_data_lab,nmsfx_temp)) ))
  ){
    # map over slash_pile_detect for dbscan
    dbscan_structural_preds <- 
      all_stand_boundary$site_data_lab %>% 
      purrr::set_names() %>% 
      purrr::map(
        \(x)
        slash_pile_detect(
            chm_rast = chm_rast[[x]]
            , seg_method = "dbscan"
            , min_ht_m = all_stand_boundary %>% dplyr::filter(site_data_lab==x) %>% dplyr::pull(min_ht_m)
            , max_ht_m = all_stand_boundary %>% dplyr::filter(site_data_lab==x) %>% dplyr::pull(max_ht_m)
            , min_area_m2 = all_stand_boundary %>% dplyr::filter(site_data_lab==x) %>% dplyr::pull(min_area_m2)
            , max_area_m2 = all_stand_boundary %>% dplyr::filter(site_data_lab==x) %>% dplyr::pull(max_area_m2)
            , min_convexity_ratio = all_stand_boundary %>% dplyr::filter(site_data_lab==x) %>% dplyr::pull(min_convexity_ratio)
            , min_circularity_ratio = all_stand_boundary %>% dplyr::filter(site_data_lab==x) %>% dplyr::pull(min_circularity_ratio)
            , ofile = file.path(dir_temp, paste0(x,nmsfx_temp))
          )
          # purrr::pluck("segs_sf")
        , .progress = T
      )
    # # write
    #   dbscan_structural_preds %>% 
    #     purrr::imap(
    #       \(x,nm)
    #       sf::st_write(
    #         obj = x
    #         , dsn = file.path(dir_temp, paste0(nm,nmsfx_temp))
    #         , append = F
    #         , quiet = T
    #       )
    #     )
    
    # read files
    dbscan_structural_preds <- dbscan_structural_preds %>% 
      purrr::map(
        \(x)
        sf::st_read(dsn = x, quiet = T)
      )
  }else{
    # read already done
    dbscan_structural_preds <- 
      all_stand_boundary$site_data_lab %>% 
      purrr::set_names() %>% 
      purrr::map(
        \(x)
        sf::st_read(
          dsn = file.path(dir_temp, paste0(x,nmsfx_temp))
          , quiet = T
        )
      )
  }
  # filter all candidate piles for only those that intersect with the study boundary
  dbscan_structural_preds <- 
      all_stand_boundary$site_data_lab %>% 
      purrr::set_names() %>% 
      purrr::map(
        \(x)
        dplyr::inner_join(
          dbscan_structural_preds[[x]]
          , dbscan_structural_preds[[x]] %>% 
            sf::st_intersection(
              stand_boundary[[x]] %>% 
              sf::st_transform(sf::st_crs(dbscan_structural_preds[[x]]))
            ) %>% 
            sf::st_drop_geometry() %>% 
            dplyr::select(pred_id) %>% 
            dplyr::mutate(is_in_stand = T)
          , by = "pred_id"
        )
      )
##################################################
# map over slash_pile_detect for watershed
##################################################
  # file.names to only run if not already done since it takes a while for all sites
  dir_temp <- "../data"
  if(!dir.exists(dir_temp)){dir.create(dir_temp,showWarnings = F)}
  nmsfx_temp <- "_watershed_structural_preds.gpkg"
  if(
    !all(file.exists( file.path(dir_temp, paste0(all_stand_boundary$site_data_lab,nmsfx_temp)) ))
  ){
    # map over slash_pile_detect for watershed
    watershed_structural_preds <- 
      all_stand_boundary$site_data_lab %>% 
      # .[2:4] %>% 
      purrr::set_names() %>% 
      purrr::map(
        \(x)
        slash_pile_detect(
            chm_rast = chm_rast[[x]]
            , seg_method = "watershed"
            , min_ht_m = all_stand_boundary %>% dplyr::filter(site_data_lab==x) %>% dplyr::pull(min_ht_m)
            , max_ht_m = all_stand_boundary %>% dplyr::filter(site_data_lab==x) %>% dplyr::pull(max_ht_m)
            , min_area_m2 = all_stand_boundary %>% dplyr::filter(site_data_lab==x) %>% dplyr::pull(min_area_m2)
            , max_area_m2 = all_stand_boundary %>% dplyr::filter(site_data_lab==x) %>% dplyr::pull(max_area_m2)
            , min_convexity_ratio = all_stand_boundary %>% dplyr::filter(site_data_lab==x) %>% dplyr::pull(min_convexity_ratio)
            , min_circularity_ratio = all_stand_boundary %>% dplyr::filter(site_data_lab==x) %>% dplyr::pull(min_circularity_ratio)
            , ofile = file.path(dir_temp, paste0(x,nmsfx_temp))
          )
          # purrr::pluck("segs_sf")
        , .progress = T
      )
    # read files
    watershed_structural_preds <- watershed_structural_preds %>% 
      purrr::map(
        \(x)
        sf::st_read(dsn = x, quiet = T)
      )
  }else{
    # read already done
    watershed_structural_preds <- 
      all_stand_boundary$site_data_lab %>% 
      purrr::set_names() %>% 
      purrr::map(
        \(x)
        sf::st_read(
          dsn = file.path(dir_temp, paste0(x,nmsfx_temp))
          , quiet = T
        )
      )
  }
  # filter all candidate piles for only those that intersect with the study boundary
  watershed_structural_preds <- 
      all_stand_boundary$site_data_lab %>% 
      purrr::set_names() %>% 
      purrr::map(
        \(x)
        dplyr::inner_join(
          watershed_structural_preds[[x]]
          , watershed_structural_preds[[x]] %>% 
            sf::st_intersection(
              stand_boundary[[x]] %>% 
              sf::st_transform(sf::st_crs(watershed_structural_preds[[x]]))
            ) %>% 
            sf::st_drop_geometry() %>% 
            dplyr::select(pred_id) %>% 
            dplyr::mutate(is_in_stand = T)
          , by = "pred_id"
        )
      )
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

let's summarize the number of structural candidate segments and the area they cover by site

```{r}
dplyr::bind_rows(
  # watershed
    watershed_structural_preds %>% 
    purrr::imap(
      \(x,nm)
      x %>% 
        sf::st_drop_geometry() %>% 
        dplyr::ungroup() %>% 
        dplyr::summarise(
          n = dplyr::n()
          , area_m2 = sum(area_m2)
        ) %>% 
        dplyr::mutate(
          site = all_stand_boundary %>% dplyr::filter(site_data_lab==nm) %>% dplyr::pull(site)
        )
    ) %>% 
    dplyr::bind_rows() %>% 
    dplyr::mutate(method = "watershed")
  , # dbscan
    dbscan_structural_preds %>% 
    purrr::imap(
      \(x,nm)
      x %>% 
        sf::st_drop_geometry() %>% 
        dplyr::ungroup() %>% 
        dplyr::summarise(
          n = dplyr::n()
          , area_m2 = sum(area_m2)
        ) %>% 
        dplyr::mutate(
          site = all_stand_boundary %>% dplyr::filter(site_data_lab==nm) %>% dplyr::pull(site)
        )
    ) %>% 
    dplyr::bind_rows() %>% 
    dplyr::mutate(method = "dbscan")
) %>% 
dplyr::mutate(
  avg_size = scales::comma(area_m2/n, accuracy = 0.1)
  , dplyr::across(
    dplyr::where(is.numeric)
    , ~scales::comma(.x,accuracy = 1)
  )
) %>% 
dplyr::relocate(site,method) %>% 
dplyr::arrange(site,method) %>% 
kableExtra::kbl(
  caption = "Structurally detected candidate segments by method and study site"
  , col.names = c(
    "site", "method"
    , "# candidates"
    , "total<br>candidate area (m<sup>2</sup>)"
    , "mean<br>candidate area (m<sup>2</sup>)"
  )
  , escape = F
  # , digits = 2
) %>% 
kableExtra::kable_styling() %>% 
kableExtra::collapse_rows(columns = 1, valign = "top")
```

### DBSCAN Candidates

We'll quickly plot the structurally-detected candidate segments using the DBSCAN method for each study site

```{r, results=F, fig.show='asis'}
# function to plot ortho
terra_plt_ortho <- function(
  ortho
  , gt_piles
  , pred_piles
  , boundary
  , title
) {
  terra::plotRGB(ortho, stretch = "lin")
  terra::plot(
    boundary %>% 
      sf::st_transform(terra::crs(ortho)) %>% 
      terra::vect()
    , add = T, border = "black", col = NA
    , main = title
  )
  terra::plot(
    gt_piles %>% 
      dplyr::filter(is_in_stand) %>% 
      sf::st_transform(terra::crs(ortho)) %>% 
      terra::vect()
    , add = T, border = "cyan", col = NA, lwd = 1.2
  )
  terra::plot(
    pred_piles %>% 
      sf::st_transform(terra::crs(ortho)) %>% 
      terra::vect()
    , add = T, border = "magenta", col = NA, lwd = 1.2
  )
}
# map over it 
all_stand_boundary$site_data_lab %>% 
  purrr::map(
    \(x)
    terra_plt_ortho(
      ortho = rgb_rast[[x]]
      , gt_piles = slash_piles_polys[[x]]
      , pred_piles = dbscan_structural_preds[[x]]
      , boundary = stand_boundary[[x]]
      , title = paste0(
        "DBSCAN: "
        , all_stand_boundary %>% dplyr::filter(site_data_lab==x) %>% dplyr::pull(site)
      )
    )
  )

```

### Watershed Candidates

We'll quickly plot the structurally-detected candidate segments using the Watershed method for each study site

```{r, results=F, fig.show='asis'}
# map over it 
all_stand_boundary$site_data_lab %>% 
  purrr::map(
    \(x)
    terra_plt_ortho(
      ortho = rgb_rast[[x]]
      , gt_piles = slash_piles_polys[[x]]
      , pred_piles = watershed_structural_preds[[x]]
      , boundary = stand_boundary[[x]]
      , title = paste0(
        "Watershed: "
        , all_stand_boundary %>% dplyr::filter(site_data_lab==x) %>% dplyr::pull(site)
      )
    )
  )
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

## Spectral Filter Slash Pile Candidates

Now, we'll apply spectral filtering of the structurally-detected candidate piles using our [data fusion approach](#data_fusion). 

we'll use slightly different spectral weighting for each site

```{r}

```


```{r}

purrr::imap(
  \(x,nm)
  x %>% 
    sf::st_drop_geometry() %>% 
    dplyr::ungroup() %>% 
    dplyr::summarise(
      n = dplyr::n()
      , area_m2 = sum(area_m2)
    ) %>% 
    dplyr::mutate(
      site = all_stand_boundary %>% dplyr::filter(site_data_lab==nm) %>% dplyr::pull(site)
    )
)
polygon_spectral_filtering(
  sf_data = slash_pile_detect_dbscan_ans_temp$segs_sf
  , rgb_rast = aoi_rgb_rast
  # define the band index
  , red_band_idx = 1
  , green_band_idx = 2
  , blue_band_idx = 3
  # leave return unfiltered
  , filter_return = F
)
```


```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```
