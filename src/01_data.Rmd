# Data Overview

We will detail the study sites and summarize the number of piles and the pile size based on available measurements.

| Site Name | Pile Type | Validation Data Type | Unique Features & Ecology | Data Collection (UAS Platform & Parameters) |
| :--- | :--- | :--- | :--- | :--- |
| **PSINF Mixed Conifer Site** | Hand Piles and smaller machine piles | Image-annotated footprints and field-measured height and diameter | Located in the Pike and San Isabel National Forest (PSINF) in CO, US. Mixed conifer stand with variable ground cover and canopy density. | Switchblade-Elite (Vision Aerial) with 24.2 MP RGB sensor (16 mm lens). Altitude xx m, 90% forward and 85% side overlap, 4 m/s speed. |
| **TRFO-BLM Pinyon-Juniper Site** | Hand Piles | Image-annotated footprints based on field collected point locations | Located on BLM land in CO, US. Arid environment with dry vegetation including standing dead pinyon-juniper. Piles are smaller, simpler, and hand-stacked. | Freefly Astro with Sony ILX-LR1 (35mm lens). Altitude 243.84 m (terrain following), 85% forward and 80% side overlap. |
| **BHEF Ponderosa Pine Site** | Machine Piles | Image-annotated footprints | Located in the Black Hills Experimental Forest (BHEF) in SD, US. Piles are massive, mechanically built, and irregularly shaped (e.g. not necessarily circular). Tree regeneration is expected. | DJI Phantom 4 Pro with 20 MP RGB sensor (8.8 mm lens). Altitude 80 m, 90% forward and 85% side overlap, 4 m/s speed. |
| **ARNF Ponderosa Pine Site** | Machine Piles | Image-annotated footprints | Located in the Arapahoe and Roosevelt National Forest (ARNF) in CO, US. Ponderosa pine forest with a climate similar to PSINF. Machine piles are massive but more circular and regular. Less regeneration is expected. | Switchblade-Elite (Vision Aerial) with 24.2 MP RGB sensor (16 mm lens). Altitude xx m, 90% forward and 85% side overlap, 4 m/s speed. |

Load the standard libraries we use to do work

```{r, warning=FALSE, message=FALSE}
# bread-and-butter
library(tidyverse) # the tidyverse
library(viridis) # viridis colors
library(harrypotter) # hp colors
library(RColorBrewer) # brewer colors
library(scales) # work with number and plot scales
library(latex2exp)

# visualization
library(mapview) # interactive html maps
library(kableExtra) # tables
library(patchwork) # combine plots
library(corrplot) # correlation plots
library(ggnewscale) # new scale

# spatial analysis
library(terra) # raster
library(sf) # simple features
library(lidR) # lidar data
library(rgl) # 3d plots
library(cloud2trees) # the cloud2trees
```

```{r, include=F, warning=F, message=F}
# knit options
knitr::opts_chunk$set(
  echo = TRUE
  , warning = FALSE
  , message = FALSE
  # , results = 'hide'
  , fig.width = 10.5
  , fig.height = 7
)
# option to put satellite imagery as base layer of mapview maps
  mapview::mapviewOptions(
    homebutton = FALSE
    # , basemaps = c("Esri.WorldImagery","OpenStreetMap")
    , basemaps = c("OpenStreetMap", "Esri.WorldImagery")
  )
# pal
pal_match_grp <- c(
  "omission"=viridis::cividis(3)[1]
  , "commission"= "gray88" #viridis::cividis(3)[2]
  , "true positive"=viridis::cividis(3)[3]
)

# clean session
remove(list = ls())
gc()

# fp
all_agg_ground_truth_match_ans_fp <- file.path("../data/","all_agg_ground_truth_match_ans.gpkg")
```

## Study Units Vector Data

let's load in all the vector data containing the study units

```{r}
# PSINF Mixed Conifer Site
psinf_stand_boundary <- sf::st_read("../data/PFDP_Data/Tree_Data/GIS/PFDP_Boundary.shp", quiet = T) %>% 
  sf::st_union() %>% 
  dplyr::mutate(site = "PSINF Mixed Conifer Site")
# TRFO-BLM Pinyon-Juniper Site
pj_stand_boundary <- 
  sf::st_read("../data/Dawson_data/units/units.shp", quiet=T) %>% 
  dplyr::rename_with(tolower) %>% 
  dplyr::rename_with(stringr::str_squish) %>% 
  dplyr::rename_with(make.names) %>% 
  dplyr::rename_with(~stringr::str_replace_all(.x, "\\.{2,}", ".")) %>% 
  dplyr::rename_with(~stringr::str_remove(.x, "\\.$")) %>% 
  dplyr::rename_with(~stringr::str_replace_all(.x, "\\.", "_")) %>% 
  dplyr::filter(tolower(unit)=="u10") %>% 
  dplyr::slice(1) %>% 
  dplyr::mutate(site = "TRFO-BLM Pinyon-Juniper Site")
# BHEF Ponderosa Pine Site
bhef_stand_boundary <- 
  sf::st_read("../data/BHEF_202306/bhef_harvests.gpkg", quiet=T) %>% 
  dplyr::rename_with(tolower) %>% 
  dplyr::rename_with(stringr::str_squish) %>% 
  dplyr::rename_with(make.names) %>% 
  dplyr::rename_with(~stringr::str_replace_all(.x, "\\.{2,}", ".")) %>% 
  dplyr::rename_with(~stringr::str_remove(.x, "\\.$")) %>% 
  dplyr::rename_with(~stringr::str_replace_all(.x, "\\.", "_")) %>% 
  dplyr::filter(
    year_id == 2021
    & !(treatment_type_grp %in% c("Improvement/Liberation Cut", "Other", "Sanitation Cut"))
    & suid %in% c("0203088082660004000","0203088082660003000") # these were the only units with machine piles in prescription
  ) %>% 
  dplyr::mutate(site = "BHEF Ponderosa Pine Site")
# ARNF Ponderosa Pine Site
arnf_stand_boundary <- 
  sf::st_read("../data/ARNF_DiamondView_202510/Diamond_View_Boundary.gpkg", quiet=T) %>% 
  sf::st_union() %>% 
  dplyr::mutate(site = "ARNF Ponderosa Pine Site")
```

we'll combine the study unit boundaries for all sites to create a spatial data set that contains all units for plotting in a single map

```{r}
# read the data
# stand boundary
all_stand_boundary <- 
  dplyr::bind_rows(
    psinf_stand_boundary %>% sf::st_transform(crs = 5070) %>% dplyr::select(site)
    , pj_stand_boundary %>% sf::st_transform(crs = 5070) %>% dplyr::select(site)
    , bhef_stand_boundary %>% sf::st_transform(crs = 5070) %>% dplyr::select(site)
    , arnf_stand_boundary %>% sf::st_transform(crs = 5070) %>% dplyr::select(site)
  ) %>% 
  sf::st_set_geometry("geometry") %>% 
  dplyr::group_by(site) %>% 
  dplyr::summarise(
    geometry = sf::st_union(geometry)
  ) %>% 
  dplyr::ungroup() %>% 
  sf::st_set_geometry("geometry") %>% 
  dplyr::mutate(
    site_area_m2 = sf::st_area(geometry) %>% as.numeric()
    , site_area_ha = site_area_m2/10000
  )
  # sf::st_centroid() %>% 
  # sf::st_sf() %>% 
```

Let's map the study sites on a single map

```{r}
sites_pal <- RColorBrewer::brewer.pal(n = nrow(all_stand_boundary), name = "Dark2")
# option to put satellite imagery as base layer of mapview maps
mapview::mapviewOptions(
  homebutton = T
  # , basemaps = c("Esri.WorldImagery","OpenStreetMap")
  , basemaps = c("OpenStreetMap", "Esri.WorldImagery")
)
# map it
mapview::mapview(
  all_stand_boundary %>% 
    dplyr::group_by(site) %>% 
    sf::st_centroid()
  , zcol="site"
  , col.regions = sites_pal
  , cex = 8
  , layer.name = "study sites"
)
```

static map for printing

let's make a pretty image for use in the journal article. we'll use the `ggmap` package to get a nice background map and do some transformation to actually work with the map. We'll add a map scale using `ggspatial`

```{r, warning=F, message=FALSE, results=F}
library(ggmap)
library(ggspatial)
#########################################################################
#########################################################################
# Make each plot individually by landscape as solution to small multiples
# this block defines function
#########################################################################
##################hack to align plots for ggmap
ggmap_bbox_fn <- function(map, my_crs=3857) {
    if (!inherits(map, "ggmap")) stop("map must be a ggmap object")
    # Extract the bounding box (in lat/lon) from the ggmap to a numeric vector, 
    # and set the names to what sf::st_bbox expects:
    map_bbox <- setNames(unlist(attr(map, "bb")), c("ymin", "xmin", "ymax", "xmax"))
    # Convert the bbox to an sf polygon, transform it to 3857, 
    # and convert back to a bbox (convoluted, but it works)
    bbox_3857 <- st_bbox(st_transform(st_as_sfc(st_bbox(map_bbox, crs = 4326)), my_crs))
    # Overwrite the bbox of the ggmap object with the transformed coordinates 
    attr(map, "bb")$ll.lat <- bbox_3857["ymin"]
    attr(map, "bb")$ll.lon <- bbox_3857["xmin"]
    attr(map, "bb")$ur.lat <- bbox_3857["ymax"]
    attr(map, "bb")$ur.lon <- bbox_3857["xmax"]
    map
}
plt_crs <- 3857
#########################################################################
#########################################################################
#########################################################################
my_ggmap_basemap <- function(sf_data, zoom_level = 14, buffer_box = 2600, my_crs = plt_crs, scale_location = "bl", my_maptype = "stamen_terrain") {
  
  # # should zoom in?
  # zoom_level <- 14 # 11
  # # should buffer extend?
  # buffer_box <- 2600 # 20000
  # bounding box
  bb_temp <-
    sf_data %>% 
    sf::st_bbox() %>% 
    sf::st_as_sfc() %>% 
    sf::st_transform(crs=5070) %>% 
    sf::st_buffer(as.numeric(buffer_box)) %>% 
    sf::st_transform(crs=4326) %>% # same as get_map return
    sf::st_bbox()
  # set bbox for get call
  bbox_temp <- c(
    bottom = bb_temp[[2]]
    , top = bb_temp[[4]]
    , right = bb_temp[[3]]
    , left = bb_temp[[1]]
  )
  hey_ggmap <- ggmap::get_stadiamap(
    bbox = bbox_temp
    , zoom = zoom_level
    , maptype = my_maptype #"stamen_terrain" #"stamen_toner_lite"
    , crop = T
  )

  # ggmap::ggmap(hey_ggmap)
  # apply align function
  hey_ggmap_aligned <- ggmap_bbox_fn(hey_ggmap, my_crs) # Use the function
  # plot
  plt_basemap <-
    ggmap::ggmap(hey_ggmap_aligned) + 
    ggplot2::coord_sf(
      expand = FALSE
    ) +
    ggplot2::theme_light() +
    ggplot2::theme(
      legend.position = "none"
      , plot.title = ggplot2::element_blank()
      , strip.text = ggplot2::element_blank()
      , axis.title = ggplot2::element_blank()
      , axis.text = ggplot2::element_blank()
      , axis.ticks = ggplot2::element_blank()
      , panel.grid = ggplot2::element_blank()
      , plot.margin = ggplot2::margin(0, 0, 0, 0, "cm")
    )
  if(scale_location %in% c("bl", "br", "tr", "tl")){
    plt_basemap <- plt_basemap + 
      ggspatial::annotation_scale(
        location = scale_location
        , style = "ticks"
        , pad_x = unit(0.1, "cm")
        , pad_y = unit(0.1, "cm")
      )
  }
  return(plt_basemap)
}
```

plot the fancy basemap with the points

```{r, fig.height=9, fig.width=7.5}
# get the basemap with our my_ggmap_basemap()
plt_basemap <- my_ggmap_basemap(
  sf_data = all_stand_boundary %>% dplyr::group_by(site) %>% sf::st_point_on_surface()
  , buffer_box = 190000
  , zoom_level = 7
  , my_maptype = "stamen_terrain"
)
# plt_basemap
# plot
plt2_temp <- 
  plt_basemap + 
    ggplot2::geom_sf(
      data = all_stand_boundary %>% 
        dplyr::group_by(site) %>% 
        sf::st_point_on_surface() %>% 
        sf::st_transform(crs=plt_crs)
      , mapping = ggplot2::aes(fill = site)
      , size = 4.5
      , inherit.aes = F
      , shape = 21
      , color = "gray88"
      , fill = "blue2"
    ) +
    ggplot2::geom_sf_label(
      data = all_stand_boundary %>% 
        dplyr::group_by(site) %>% 
        sf::st_point_on_surface() %>% 
        sf::st_transform(crs=plt_crs)
      , mapping = ggplot2::aes(label = stringr::str_wrap(site, width = 40))
      , size = 2.5
      , hjust = -0.055
      , vjust = 0.4
      , inherit.aes = F
    ) +
    ggplot2::scale_fill_manual(values = sites_pal)
plt2_temp
```

```{r, include=FALSE, eval=TRUE}
ggplot2::ggsave(
  "../data/all_agg_ground_truth_match_ans.jpg"
  , dpi = "print"
  , height = 9, width = 7.5
)
```

what is the area of the treatment unit boundaries we are looking over?

```{r}
all_stand_boundary %>% 
  sf::st_drop_geometry() %>% 
  dplyr::select(site, site_area_ha) %>% 
  dplyr::mutate(
    site_area_ha = scales::comma(site_area_ha, suffix = " ha", accuracy = 0.1)
  ) %>% 
  kableExtra::kbl(
    caption = caption
    , col.names = c(
      "site", "hectares"
    )
    , escape = F
  ) %>% 
  kableExtra::kable_styling()
```

## Slash Pile Vector Data

Image-annotated pile footprints at each study site were created in a GIS by outlining pile boundaries on the RGB orthomosaic and confirming the vertical structure using fine-resolution CHM data (e.g., 0.15m resolution). Field-collected points were used to ensure pile census completeness at the hand-pile study sites (PSINF Mixed Conifer Site and TRFO-BLM Pinyon-Juniper Site) to pinpoint piles that were otherwise challenging to delineate from the aerial imagery and CHM data alone. Machine piles were easily distinguishable using the RGB and CHM data.

Let's load in those image-annotated pile polygons now for each study site.

```{r}
#######################################
# polygons annotated using RGB and field-collected points
#######################################
###########################
# PSINF Mixed Conifer Site
###########################
  psinf_slash_piles_polys <- sf::st_read(
      "../data/PFDP_Data/PFDP_SlashPiles/manitou_pile_polys.shp"
      , quiet = T
    ) %>% 
    dplyr::rename_with(tolower) %>% 
    sf::st_make_valid() %>% 
    dplyr::filter(sf::st_is_valid(.)) %>% 
    # fix multipolygons
    dplyr::ungroup() %>% 
    dplyr::mutate(treeID = dplyr::row_number()) %>% 
    cloud2trees::simplify_multipolygon_crowns() %>% 
    dplyr::select(-c(treeID, shape_leng, shape_area))
  
  # points recorded in field
  psinf_slash_piles_points <- sf::st_read(
      "../data/PFDP_Data/PFDP_SlashPiles/SlashPiles.shp"
      , quiet = T
    ) %>% 
    dplyr::rename_with(tolower) %>% 
    sf::st_zm() %>% 
    sf::st_transform(sf::st_crs(psinf_slash_piles_polys)) %>% 
    dplyr::filter( !(objectid %in% c(43)) ) %>% # duplicate field points
    dplyr::mutate(row_number = dplyr::row_number()) %>% 
    dplyr::select(-c(objectid)) %>% 
    dplyr::rename(
      height_ft = height
      , diameter_ft = diameter
    )
  # update unit boundary to pile proj
  psinf_stand_boundary <- psinf_stand_boundary %>% sf::st_transform(sf::st_crs(psinf_slash_piles_polys))
  
  # attach flag for spatial overlap with unit boundary
  psinf_slash_piles_polys <- psinf_slash_piles_polys %>%
    dplyr::left_join(
      psinf_slash_piles_polys %>% 
        sf::st_intersection(psinf_stand_boundary) %>% 
        sf::st_drop_geometry() %>% 
        dplyr::select(pile_id) %>% 
        dplyr:mutate(is_in_stand = T)
      , by = "pile_id"
    ) %>% 
    dplyr::mutate(
      is_in_stand = dplyr::coalesce(is_in_stand, F)
    )
###########################
# TRFO-BLM Pinyon-Juniper Site
###########################
  pj_slash_piles_polys <- 
    sf::st_read("../data/Dawson_Data/piles/pj_pile_polys.shp", quiet=T) %>% 
    dplyr::rename_with(tolower) %>% 
    sf::st_make_valid() %>% 
    dplyr::filter(sf::st_is_valid(.)) %>% 
    # fix multipolygons
    dplyr::mutate(
      pile_id = dplyr::row_number()
      , treeID = dplyr::row_number()
    ) %>% 
    cloud2trees::simplify_multipolygon_crowns() %>%
    dplyr::select(-c(treeID,id)) %>% 
    dplyr::filter(pile_id!=62)
  
  # points recorded in field
  # these piles were collected twice in the same location and have different measurements :\
  bad_pile_ids_temp <- c(
    142
    , 146
    , 99
    , 96
    , 50
  )
  pj_slash_piles_points <- 
    readr::read_csv("../data/Dawson_data/PJ_Piles_Unit_10.csv") %>% 
    dplyr::rename_with(tolower) %>% 
    dplyr::rename_with(stringr::str_squish) %>% 
    dplyr::rename_with(make.names) %>% 
    dplyr::rename_with(~stringr::str_replace_all(.x, "\\.{2,}", ".")) %>% 
    dplyr::rename_with(~stringr::str_remove(.x, "\\.$")) %>% 
    dplyr::rename_with(~stringr::str_replace_all(.x, "\\.", "_")) %>% 
    dplyr::mutate(
      orig_pile_id = tidyr::extract_numeric(name)
    ) %>% 
    dplyr::filter(
      !(orig_pile_id %in% bad_pile_ids_temp)
    ) %>% 
    sf::st_as_sf(coords = c("easting","northing"), crs = 6342, remove = F) %>% 
    dplyr::select(orig_pile_id,name,height_m,width_m,easting,northing,latitude,longitude,code,description,elevation) %>% 
    sf::st_make_valid() %>% 
    sf::st_transform(sf::st_crs(pj_slash_piles_polys))
  
  # update unit boundary to pile proj
  pj_stand_boundary <- pj_stand_boundary %>% sf::st_transform(sf::st_crs(pj_slash_piles_polys))
  
  # attach flag for spatial overlap with unit boundary
  pj_slash_piles_polys <- pj_slash_piles_polys %>%
    dplyr::left_join(
      pj_slash_piles_polys %>% 
        sf::st_intersection(pj_stand_boundary) %>% 
        sf::st_drop_geometry() %>% 
        dplyr::select(pile_id) %>% 
        dplyr:mutate(is_in_stand = T)
      , by = "pile_id"
    ) %>% 
    dplyr::mutate(
      is_in_stand = dplyr::coalesce(is_in_stand, F)
    )
###########################  
# BHEF Ponderosa Pine Site
###########################  
  bhef_slash_piles_polys <- 
    sf::st_read("../data/BHEF_202306/piles/bhef_pile_polys.shp", quiet=T) %>% 
    dplyr::rename_with(tolower) %>% 
    sf::st_make_valid() %>% 
    dplyr::filter(sf::st_is_valid(.)) %>% 
    # fix multipolygons
    dplyr::mutate(
      pile_id = dplyr::row_number()
      , treeID = dplyr::row_number()
    ) %>% 
    cloud2trees::simplify_multipolygon_crowns() %>%
    dplyr::select(-c(treeID))
  
  # update unit boundary to pile proj
  bhef_stand_boundary <- bhef_stand_boundary %>% sf::st_transform(sf::st_crs(bhef_slash_piles_polys))
  
  # attach flag for spatial overlap with unit boundary
  bhef_slash_piles_polys <- bhef_slash_piles_polys %>%
    dplyr::left_join(
      bhef_slash_piles_polys %>% 
        sf::st_intersection(bhef_stand_boundary) %>% 
        sf::st_drop_geometry() %>% 
        dplyr::select(pile_id) %>% 
        dplyr:mutate(is_in_stand = T)
      , by = "pile_id"
    ) %>% 
    dplyr::mutate(
      is_in_stand = dplyr::coalesce(is_in_stand, F)
    )
###########################  
# ARNF Ponderosa Pine Site
###########################  
  arnf_slash_piles_polys <- 
    sf::st_read("../data/ARNF_DiamondView_202510/arnf_diamond_view_pile_polys.shp", quiet=T) %>% 
    dplyr::rename_with(tolower) %>% 
    sf::st_make_valid() %>% 
    dplyr::filter(sf::st_is_valid(.)) %>% 
    # fix multipolygons
    dplyr::mutate(
      pile_id = dplyr::row_number()
      , treeID = dplyr::row_number()
    ) %>% 
    cloud2trees::simplify_multipolygon_crowns() %>%
    dplyr::select(-c(treeID))
  
  # update unit boundary to pile proj
  arnf_stand_boundary <- arnf_stand_boundary %>% sf::st_transform(sf::st_crs(arnf_slash_piles_polys))
  
  # attach flag for spatial overlap with unit boundary
  arnf_slash_piles_polys <- arnf_slash_piles_polys %>%
    dplyr::left_join(
      arnf_slash_piles_polys %>% 
        sf::st_intersection(arnf_stand_boundary) %>% 
        sf::st_drop_geometry() %>% 
        dplyr::select(pile_id) %>% 
        dplyr:mutate(is_in_stand = T)
      , by = "pile_id"
    ) %>% 
    dplyr::mutate(
      is_in_stand = dplyr::coalesce(is_in_stand, F)
    )
```

For the sites with field-collected point data, each point may not necessarily fall within the polygon boundary (e.g. due to misalignment between the imagery and point locations or slight inaccuracies in either the point or pile boundaries). So, we need to perform a matching process to tie the points to the polygons so that we get the height and diameter measured during the point collection attached to the polygons. to do this, we'll use a two-stage process that first attaches the points data frame to polygons where points fall within, using a spatial intersection. It then finds and assigns the remaining, unjoined points to their nearest polygon. The final output includes all polygons from the original data, ensuring that every polygon is represented even if no points were matched. 

```{r}
# function to perform a two-step spatial join
  # first matching points that fall inside polygons and 
  # then assigning the remaining points to the nearest polygon
  # all original polygons are returned in the final output
match_points_to_polygons <- function(
    points_sf
    , polygons_sf
    , point_id
    , polygon_id
) {
  
  # check if point_id column exists in points_sf
  if (!point_id %in% names(points_sf)) {
    stop(paste0("column '", point_id, "' not found in points_sf."))
  }
  
  # check if polygon_id column exists in polygons_sf
  if (!polygon_id %in% names(polygons_sf)) {
    stop(paste0("column '", polygon_id, "' not found in polygons_sf."))
  }
  
  # 1. ensure the crs are the same.
  if (sf::st_crs(points_sf) != sf::st_crs(polygons_sf)) {
    points_sf <- sf::st_transform(points_sf, sf::st_crs(polygons_sf))
  }
  
  # 2. Perform a standard spatial join for points within polygons.
  # Use an inner join (`left = FALSE`) to get only points that fall inside.
  points_within <- sf::st_join(
    x = points_sf
    , y = polygons_sf
    , join = sf::st_intersects
    , left = FALSE
  )
  
  # 3. Identify points that were not matched in the first step.
  matched_points_ids <- points_within[[point_id]]
  unmatched_points <- points_sf[!points_sf[[point_id]] %in% matched_points_ids, ]
  
  if (nrow(unmatched_points) > 0) {
    # 4. For the remaining points, find the index of the nearest polygon.
    nearest_polygon_index <- sf::st_nearest_feature(unmatched_points, polygons_sf)
    
    # 5. Extract the nearest polygons and join their attributes to the unmatched points.
    nearest_polygons <- polygons_sf[nearest_polygon_index, ]
    points_nearest <- data.frame(unmatched_points, sf::st_drop_geometry(nearest_polygons))
    
    # Preserve the geometry from the original unmatched points for the nearest matches.
    points_nearest <- sf::st_set_geometry(points_nearest, sf::st_geometry(unmatched_points))
    
    # 6. Combine the results from the "points_within" and "points_nearest" joins.
    combined_points <- dplyr::bind_rows(points_within, points_nearest)
    
  } else {
    # If all points were matched in step 2.
    combined_points <- points_within
  }
  
  # 7. Perform a left join to ensure all original polygons are included in the final output.
  # Polygons without any matched points will have `NA` values for the point attributes.
  final_result <- polygons_sf %>% 
    dplyr::left_join(
      sf::st_drop_geometry(combined_points)
      , by = polygon_id
    )
  
  return(final_result)
}
```

we'll also define a function to get the diameter of the polygon which we will use to extract diameter from our predicted segments to compare with the field-measured diameter values. we can also compare the field-measured diameter to the image-annotated diameter as a sanity check.

let's define a function to get polygon diameter that accurately reflects the measurement for potentially irregular shapes. we'll calculate the diameter by finding the maximum distance across the footprint of the entire polygon

```{r}
###___________________________________________###
# calculate diameter of single polygon
###___________________________________________###
# function to calculate the diamater of an sf polygon that is potentially irregularly shaped
# using the distance between the farthest points
st_calculate_diameter_polygon <- function(polygon) {
  # get the convex hull
  ch <- sf::st_convex_hull(polygon)

  # cast to multipoint then point to get individual vertices
  ch_points <- sf::st_cast(ch, 'MULTIPOINT') %>% sf::st_cast('POINT')

  # calculate the distances between all pairs of points
  distances <- sf::st_distance(ch_points)

  # find the maximum distance, which is the diameter
  diameter <- as.numeric(max(distances,na.rm=T))
  return(diameter)
}
# apply st to sf data
st_calculate_diameter <- function(sf_data) {
  if(!inherits(sf_data,"sf")){stop("st_calculate_diameter() requires polygon sf data")}
  if(
    !all( sf::st_is(sf_data, c("POLYGON","MULTIPOLYGON")) )
  ){
    stop("st_calculate_diameter() requires polygon sf data")
  }

  # get the geometry column name
  geom_col_name <- attr(sf_data, "sf_column")

  # calculate diameter
  # !!rlang::sym() unquotes the geometry column
  return_dta <- sf_data %>% 
    dplyr::ungroup() %>% 
    dplyr::rowwise() %>%
    dplyr::mutate(diameter_m = st_calculate_diameter_polygon( !!rlang::sym(geom_col_name) )) %>%
    dplyr::ungroup()
  return(return_dta)
}
```

let's apply our `match_points_to_polygons()` and `st_calculate_diameter()` functions

For only the PSINF mixed conifer site, slash pile field measurements were taken by measuring the height and diameter (longest side of pile) using a laser hypsometer

For volume estimation, we'll model the ground truth slash piles as a paraboloid, specifically a parabolic dome, assuming a perfectly circular base and sides curved smoothly to a peak. Assuming a paraboloid shape is common for quantifying slash pile volume ([Hardy 1996](https://permanent.fdlp.gov/gpo45282/index.htm); [Long & Boston 2014](https://doi.org/10.5849/forsci.13-501)) and may better represent the diverse shapes of real-world slash piles than assuming a conical or half-sphere form. A paraboloid can represent a variety of shapes including those that are taller and more conical, or flatter and more spread out, because it allows the measured height and width to influence the volume calculation independently. This makes the paraboloid potentially more robust for estimating volumes of piles with varying aspect ratios. 

the volume formula for a paraboloid is:
  
$$
V = \frac{1}{8}\pi \cdot width^2 \cdot height
$$


```{r}
# PSINF Mixed Conifer Site
psinf_slash_piles_polys <-
  match_points_to_polygons(
    points_sf = psinf_slash_piles_points 
    , polygons_sf = psinf_slash_piles_polys
    , point_id = "row_number"
    , polygon_id = "pile_id"
  ) %>% 
  dplyr::ungroup() %>%
  sf::st_make_valid() %>%
  dplyr::filter(sf::st_is_valid(.)) %>% 
  st_calculate_diameter() %>% 
  dplyr::rename(image_gt_diameter_m = diameter_m) %>% 
  # calculate area and volume
  dplyr::mutate(
    # height 
    height_m = height_ft*0.3048
    , field_diameter_m = diameter_ft*0.3048 # *0.3048 or /3.281 to convert to m
    , field_radius_m = (field_diameter_m/2)
    , image_gt_area_m2 = sf::st_area(.) %>% as.numeric()
    , field_gt_area_m2 = pi*field_radius_m^2 
    # volume ASSUMING PERFECT GEOMETRIC SHAPE :/
    , image_gt_volume_m3 = (1/8) * pi * ( (sqrt(image_gt_area_m2/pi)*2)^2 ) * height_m # (1/8) * pi * (shape_length^2) * max_height_m
    , field_gt_volume_m3 = (1/8) * pi * (field_diameter_m^2) * height_m # (1/8) * pi * (shape_length^2) * max_height_m
  )
# TRFO-BLM Pinyon-Juniper Site
pj_slash_piles_polys <-
  match_points_to_polygons(
    points_sf = pj_slash_piles_points 
    , polygons_sf = pj_slash_piles_polys
    , point_id = "orig_pile_id"
    , polygon_id = "pile_id"
  ) %>% 
  dplyr::ungroup() %>%
  sf::st_make_valid() %>%
  dplyr::filter(sf::st_is_valid(.)) %>% 
  st_calculate_diameter() %>% 
  dplyr::rename(image_gt_diameter_m = diameter_m) %>% 
  # calculate area and volume
  dplyr::mutate(
    # height 
    height_m = height_m
    , field_diameter_m = width_m
    , field_radius_m = (field_diameter_m/2)
    , image_gt_area_m2 = sf::st_area(.) %>% as.numeric()
    , field_gt_area_m2 = pi*field_radius_m^2 
    # volume ASSUMING PERFECT GEOMETRIC SHAPE :/
    , image_gt_volume_m3 = (1/8) * pi * ( (sqrt(image_gt_area_m2/pi)*2)^2 ) * height_m # (1/8) * pi * (shape_length^2) * max_height_m
    , field_gt_volume_m3 = (1/8) * pi * (field_diameter_m^2) * height_m # (1/8) * pi * (shape_length^2) * max_height_m
  )
# BHEF Ponderosa Pine Site
bhef_slash_piles_polys <-
  bhef_slash_piles_polys %>% 
  st_calculate_diameter() %>% 
  dplyr::rename(image_gt_diameter_m = diameter_m) %>% 
  # calculate area and volume
  dplyr::mutate(
    image_gt_area_m2 = sf::st_area(.) %>% as.numeric()
  )
# ARNF Ponderosa Pine Site
arnf_slash_piles_polys <-
  arnf_slash_piles_polys %>% 
  st_calculate_diameter() %>% 
  dplyr::rename(image_gt_diameter_m = diameter_m) %>% 
  # calculate area and volume
  dplyr::mutate(
    image_gt_area_m2 = sf::st_area(.) %>% as.numeric()
  )

xxx
```


---

Slash pile field measurements were taken by measuring the height and diameter (longest side of pile) using a laser hypsometer

For volume estimation, we'll model the ground truth slash piles as a paraboloid, specifically a parabolic dome, assuming a perfectly circular base and sides curved smoothly to a peak. Assuming a paraboloid shape is common for quantifying slash pile volume ([Hardy 1996](https://permanent.fdlp.gov/gpo45282/index.htm); [Long & Boston 2014](https://doi.org/10.5849/forsci.13-501)) and may better represent the diverse shapes of real-world slash piles than assuming a conical or half-sphere form. A paraboloid can represent a variety of shapes including those that are taller and more conical, or flatter and more spread out, because it allows the measured height and width to influence the volume calculation independently. This makes the paraboloid potentially more robust for estimating volumes of piles with varying aspect ratios. 

the volume formula for a paraboloid is:
  
$$
V = \frac{1}{8}\pi \cdot width^2 \cdot height
$$


```{r}
# polygons annotated using RGB and field-collected points
slash_piles_polys <- sf::st_read(
    "../data/PFDP_Data/PFDP_SlashPiles/manitou_pile_polys.shp"
    # "f:\\PFDP_Data\\PFDP_SlashPiles\\SlashPiles_Polygons.shp"
    , quiet = T
  ) %>% 
  dplyr::rename_with(tolower) %>% 
  sf::st_make_valid() %>% 
  dplyr::filter(sf::st_is_valid(.)) %>% 
  # fix multipolygons
  dplyr::ungroup() %>% 
  dplyr::mutate(treeID = dplyr::row_number()) %>% 
  cloud2trees::simplify_multipolygon_crowns() %>% 
  dplyr::select(-c(treeID, shape_leng, shape_area))
# slash_piles_polys %>% dplyr::glimpse()

# points recorded in field
slash_piles_points <- sf::st_read(
    "../data/PFDP_Data/PFDP_SlashPiles/SlashPiles.shp"
    # "f:\\PFDP_Data\\PFDP_SlashPiles\\SlashPiles.shp"
    , quiet = T
  ) %>% 
  dplyr::rename_with(tolower) %>% 
  sf::st_zm() %>% 
  sf::st_transform(sf::st_crs(slash_piles_polys)) %>% 
  dplyr::filter( !(objectid %in% c(43)) ) %>% # duplicate field points
  dplyr::mutate(row_number = dplyr::row_number()) %>% 
  dplyr::select(-c(objectid)) %>% 
  dplyr::rename(
    height_ft = height
    , diameter_ft = diameter
  )

# stand boundary
stand_boundary <- sf::st_read("../data/PFDP_Data/Tree_Data/GIS/PFDP_Boundary.shp", quiet = T) %>% 
  sf::st_transform(sf::st_crs(slash_piles_polys)) %>% 
  sf::st_union()
```

what is the area of the treatment unit boundaries we are looking over?

```{r}
stand_boundary %>% 
  sf::st_area() %>% 
  as.numeric() %>% 
  `/`(10000) %>% 
  scales::comma(suffix = " ha", accuracy = 0.1)
```

that's great

let's check this on the map

```{r}
# mapview::mapview(slash_piles_points, zcol = "comment", layer.name = "slash piles")
mapview::mapview(
  stand_boundary
  , color = "black"
  , lwd = 1
  , alpha.regions = 0
  , label = FALSE
  , legend = FALSE
  , popup = FALSE
  , layer.name = "stand boundary"
) +
# mapview::mapview(slash_piles_polys, zcol = "is_in_stand", layer.name = "'in' slash piles") +
mapview::mapview(slash_piles_polys, col.regions = "navy", col = NA, layer.name = "pile polys", legend = FALSE) +
mapview::mapview(slash_piles_points, cex = 2, col.regions = "gold", color = "gold", layer.name = "pile points")
```



summary statistics for the form measurements

```{r}
kbl_form_sum_stats <- function(
  pile_df
  , caption = "Ground Truth Piles: summary statistics for form measurements"
) {
pile_df %>% 
  sf::st_drop_geometry() %>% 
  dplyr::select(
    tidyselect::contains("height_m")
    | tidyselect::contains("diameter_m")
    | tidyselect::contains("area_m2")
    | tidyselect::contains("volume_m3")
  ) %>% 
  dplyr::summarise(
    dplyr::across(
      dplyr::everything()
      , .fns = list(
        mean = ~mean(.x,na.rm=T)
        , sd = ~sd(.x,na.rm=T)
        , q10 = ~quantile(.x,na.rm=T,probs=0.1)
        , q50 = ~quantile(.x,na.rm=T,probs=0.5)
        , q90 = ~quantile(.x,na.rm=T,probs=0.9)
        , min = ~min(.x,na.rm=T)
        , max = ~max(.x,na.rm=T)
      )
    )
    , n = dplyr::n()
  ) %>% 
  dplyr::ungroup() %>% 
  tidyr::pivot_longer(cols = -c(n)) %>% 
  dplyr::mutate(
    agg = stringr::word(name,-1,sep = "_")
    , metric = stringr::str_remove_all(name, paste0("_",agg)) %>% 
      stringr::str_extract("(paraboloid_volume|volume|area|height|diameter)") %>% 
      dplyr::coalesce("detection") %>% 
      stringr::str_c(
        dplyr::case_when(
          stringr::str_detect(name,"(field|image)") ~ paste0(" (", stringr::str_extract(name,"(field|image)"), ")")
          , T ~ ""
        )
      ) %>% 
      stringr::str_replace("area", "area m<sup>2</sup>") %>% 
      stringr::str_replace("volume", "volume m<sup>3</sup>") %>% 
      stringr::str_replace("diameter", "diameter m") %>% 
      stringr::str_replace("height", "height m") %>% 
      stringr::str_to_sentence()
  ) %>% 
  # dplyr::count(metric)
  dplyr::select(-name) %>% 
  dplyr::mutate(
    value = dplyr::case_when(
      # metric == "gt_height_m" ~ scales::comma(value,accuracy=0.1)
      T ~ scales::comma(value,accuracy=0.1)
    )
  ) %>% 
  tidyr::pivot_wider(names_from = agg, values_from = value) %>% 
  dplyr::mutate(
    range = paste0(min, "—", max)
  ) %>% 
  dplyr::arrange(desc(n)) %>% 
  dplyr::select(-c(min,max)) %>% 
  kableExtra::kbl(
    caption = caption
    , col.names = c(
      "# piles", "Metric"
      , "Mean"
      , "Std Dev"
      , "q 10%", "Median", "q 90%"
      , "Range"
    )
    , escape = F
    # , digits = 2
  ) %>% 
  kableExtra::kable_styling(font_size = 13) %>% 
  kableExtra::collapse_rows(columns = 1, valign = "top")
}
```

```{r}
kbl_form_sum_stats(
  slash_piles_polys %>% dplyr::filter(is_in_stand) %>% dplyr::select(!tidyselect::contains("volume_m3"))
  , caption = "Ground Truth Piles: summary statistics for form measurements<br>ponderosa pine training site"
)
```

let's check the field-collected and image-annotated measurements of diameter which will serve as a good sanity check for our image-annotation process (assuming diameter was accurately measured in the field...might be a perilous assumption)

```{r}
slash_piles_polys %>% 
  dplyr::mutate(diff_diameter_m = image_gt_diameter_m - field_diameter_m) %>% 
  ggplot2::ggplot(mapping = ggplot2::aes(x = image_gt_diameter_m, y = field_diameter_m)) +
  ggplot2::geom_abline(lwd = 1.5) +
  ggplot2::geom_point(ggplot2::aes(color = diff_diameter_m)) +
  ggplot2::geom_smooth(method = "lm", se=F, color = "tomato", linetype = "dashed") +
  ggplot2::scale_color_viridis_c(option = "mako", direction = -1, alpha = 0.8) +
  ggplot2::scale_x_continuous(limits = c(0, max( max(slash_piles_polys$field_diameter_m,na.rm=T), max(slash_piles_polys$image_gt_diameter_m,na.rm=T) ) )) +
  ggplot2::scale_y_continuous(limits = c(0, max( max(slash_piles_polys$field_diameter_m,na.rm=T), max(slash_piles_polys$image_gt_diameter_m,na.rm=T) ) )) +
  ggplot2::labs(
    x = "image-annotated diameter (m)", y = "field-collected diameter (m)"
    , color = "image-field\ndiameter diff."
    , subtitle = "diameter (m) comparison"
  ) +
  ggplot2::theme_light()
```

the plot makes these values look very similar with the image-annotated diameter generally larger than the field-collected value. let's check these using `lm()`

```{r}
lm_temp <- lm(field_diameter_m ~ image_gt_diameter_m, data = slash_piles_polys)
summary(lm_temp)
```

Our slope of `r scales::comma(lm_temp$coefficients[2], accuracy = 0.01)` is close to 1 and, along with our high R-squared value of `r scales::percent(summary(lm_temp)$r.squared, accuracy = 1)`, indicate our image- and field-measured diameters are well-calibrated

let's check the field-collected and image-annotated measurements of volume and area. for both volume measurements, a paraboloid geometry is assumed for calculation with the image-annotated volume relying on the field-collected heights

```{r}
p1_temp <- slash_piles_polys %>% 
  ggplot2::ggplot(mapping = ggplot2::aes(x = image_gt_area_m2, y =field_gt_area_m2)) +
  ggplot2::geom_abline(lwd = 1.5) +
  ggplot2::geom_point(ggplot2::aes(color = height_m)) +
  ggplot2::geom_smooth(method = "lm", se=F, color = "tomato", linetype = "dashed") +
  ggplot2::scale_color_viridis_c(option = "mako", direction = -1, alpha = 0.8) +
  ggplot2::scale_x_continuous(limits = c(0, max( max(slash_piles_polys$field_gt_area_m2,na.rm=T), max(slash_piles_polys$image_gt_area_m2,na.rm=T) ) )) +
  ggplot2::scale_y_continuous(limits = c(0, max( max(slash_piles_polys$field_gt_area_m2,na.rm=T), max(slash_piles_polys$image_gt_area_m2,na.rm=T) ) )) +
  ggplot2::labs(
    x = "image-annotated area (m2)", y = "field-collected area (m2)"
    , color = "height (m)"
    , subtitle = "area (m2) comparison"
  ) +
  ggplot2::theme_light()
p2_temp <-
  slash_piles_polys %>% 
  ggplot2::ggplot(mapping = ggplot2::aes(x = image_gt_volume_m3, y =field_gt_volume_m3)) +
  ggplot2::geom_abline(lwd = 1.5) +
  ggplot2::geom_point(ggplot2::aes(color = height_m)) +
  ggplot2::geom_smooth(method = "lm", se=F, color = "tomato", linetype = "dashed") +
  ggplot2::scale_color_viridis_c(option = "mako", direction = -1, alpha = 0.8) +
  ggplot2::scale_x_continuous(limits = c(0, max( max(slash_piles_polys$field_gt_volume_m3,na.rm=T), max(slash_piles_polys$image_gt_volume_m3,na.rm=T) ) )) +
  ggplot2::scale_y_continuous(limits = c(0, max( max(slash_piles_polys$field_gt_volume_m3,na.rm=T), max(slash_piles_polys$image_gt_volume_m3,na.rm=T) ) )) +
  ggplot2::labs(
    x = "image-annotated volume (m3)", y = "field-collected volume (m3)"
    , color = "height (m)"
    , subtitle = "volume (m3) comparison"
  ) +
  ggplot2::theme_light()
patchwork::wrap_plots(list(p1_temp,p2_temp), guides = "collect") &
  ggplot2::theme(legend.position = "bottom")
```

even assuming a perfectly circular base for the area of the field-collected data (i.e. based on measured diameter), our image-annotated values are in-line with the field-collected data as we saw with the diameter comparison

quick summary of these measurements

```{r}
slash_piles_polys %>% 
  sf::st_drop_geometry() %>% 
  dplyr::select(height_m, tidyselect::ends_with("area_m2"), tidyselect::ends_with("volume_m3")) %>% 
  summary()
```

```{r, include=FALSE,eval=FALSE}
slash_piles_polys %>% 
  sf::st_drop_geometry() %>% 
  dplyr::filter(is_in_stand) %>% 
  dplyr::select(height_m, tidyselect::ends_with("area_m2")) %>% 
  dplyr::summarise(
    dplyr::across(
      .cols = dplyr::everything()
      , list(p90 = ~quantile(.x,probs=0.90), p95 = ~quantile(.x,probs=0.95), p98 = ~quantile(.x,probs=0.98))
    )
  )
```

## RGB orthomosaic

Orthomosaic `tif` files from the UAS flight imagery that were created in [Agisoft Metashape](https://www.agisoft.com/) are loaded and stitched together via `terra::mosaic`.

```{r ortho-ld, results = 'hide'}
  # read list of orthos
  ortho_list_temp <- list.files(
    "f:\\PFDP_Data\\p4pro_images\\P4Pro_06_17_2021_half_half_optimal\\3_dsm_ortho\\2_mosaic"
    , pattern = "*\\.(tif|tiff)$", full.names = T)[] %>% 
    purrr::map(function(x){terra::rast(x)})
  
  ortho_list_temp[[1]] %>% terra::res()
  #   terra::aggregate(20) %>%
  #   terra::plotRGB(r = 1, g = 2, b = 3, stretch = "hist", colNA = "transparent")
  
  ####### ensure the resolution of the rasters matches 
    # terra::res(ortho_list_temp[[1]])
    
    ## function
    change_res_fn <- function(r, my_res=1, m = "bilinear"){
      r2 <- r
      terra::res(r2) <- my_res
      r2 <- terra::resample(r, r2, method = m)
      return(r2)
    }
    ## apply the function
    ortho_list_temp <- 1:length(ortho_list_temp) %>% 
      purrr::map(function(x){change_res_fn(ortho_list_temp[[x]], my_res=0.10)})
    
    # terra::res(ortho_list_temp[[1]])
    
    # ortho_list_temp[[1]] %>%
    #   terra::aggregate(2) %>%
    #   terra::plotRGB(r = 1, g = 2, b = 3, stretch = "hist", colNA = "transparent")

  ######## mosaic the raster list 
    ortho_rast <- terra::mosaic(
      terra::sprc(ortho_list_temp)
      , fun = "min" # min only thing that works
    ) 
    
    names(ortho_rast) <- c("red","green","blue","alpha")
    
  # ortho_rast %>%
  #   terra::aggregate(4) %>%
  #   terra::plotRGB(r = 1, g = 2, b = 3, stretch = "lin", colNA = "transparent")
```

make a function to plot the RGB imagery as a background for `ggplot2` plots

```{r}
######################################################################################
# function to plot ortho + stand
######################################################################################
ortho_plt_fn = function(my_ortho_rast = ortho_rast, stand = las_ctg_dta %>% sf::st_union() %>% sf::st_as_sf(), buffer = 20){
# convert to stars
  ortho_st <- my_ortho_rast %>%  
    terra::subset(subset = c(1,2,3)) %>%
    terra::crop(
      stand %>% sf::st_buffer(buffer) %>% terra::vect()
    ) %>% 
    # terra::aggregate(fact = 2, fun = "mean", na.rm = T) %>% 
    stars::st_as_stars()
  
  # convert to rgb
  ortho_rgb <- stars::st_rgb(
    ortho_st[,,,1:3]
    , dimension = 3
    , use_alpha = FALSE
    # , stretch = "histogram"
    , probs = c(0.005, 0.995)
    , stretch = "percent"
  )
  # ggplot
  plt_rgb <- ggplot2::ggplot() +
    stars::geom_stars(data = ortho_rgb[]) +
    ggplot2::scale_fill_identity(na.value = "transparent") + # !!! don't take this out or RGB plot will kill your computer
    ggplot2::scale_x_continuous(expand = c(0, 0)) +
    ggplot2::scale_y_continuous(expand = c(0, 0)) +
    ggplot2::labs(
      x = ""
      , y = ""
    ) +
    ggplot2::theme_void()
  
  # return(plt_rgb)
  # combine all plot elements
  plt_combine = plt_rgb +
    # geom_sf(
    #   data = stand
    #   , alpha = 0
    #   , lwd = 1.5
    #   , color = "gray22"
    # ) +
    ggplot2::theme(
      legend.position = "top" # c(0.5,1)
      , legend.direction = "horizontal"
      , legend.margin = ggplot2::margin(0,0,0,0)
      , legend.text = ggplot2::element_text(size = 8)
      , legend.title = ggplot2::element_text(size = 8)
      , legend.key = ggplot2::element_rect(fill = "white")
      # , plot.title = ggtext::element_markdown(size = 10, hjust = 0.5)
      , plot.title = ggplot2::element_text(size = 8, hjust = 0.5, face = "bold")
      , plot.subtitle = ggplot2::element_text(size = 6, hjust = 0.5, face = "italic")
    )
  return(plt_combine)
}
```

plot an example slash pile RGB image

```{r}
stand_temp <- slash_piles_polys %>%
    dplyr::filter(tolower(comment)=="mechanical pile") %>% 
    dplyr::arrange(desc(field_diameter_m)) %>% 
    dplyr::slice(1) %>% 
    sf::st_point_on_surface() %>% 
    sf::st_buffer(10, endCapStyle = "SQUARE") %>% 
    sf::st_transform(terra::crs(ortho_rast))
# check it with the ortho
ortho_plt_fn(stand = stand_temp)
ggsave("../data/pile_rgb.jpeg", height = 5, width = 5)
```

### Example ratio-based index

While hyperspectral image data enables more detailed analysis by capturing a broader spectral range than RGB imagery, we can still perform robust analysis using spectral data in the visible range

let’s define a general function for a ratio based (e.g. vegetation) index

```{r}
spectral_index_fn <- function(rast, layer1, layer2) {
  bk <- rast[[layer1]]
  bi <- rast[[layer2]]
  vi <- (bk - bi) / (bk + bi)
  return(vi)
}
```

The Green-Red Vegetation Index (GRVI) uses the reflectance of green and red bands to assess vegetation health and identify ground cover types. The formula is GRVI = (green - red) / (green + red). Higher GRVI values indicate healthy vegetation, while negative values suggest soils, and values near zero may indicate water or snow.

```{r}
grvi_rast <- spectral_index_fn(rast = ortho_rast, layer1 = 2, layer2 = 1)
names(grvi_rast) <- c("grvi")
terra::plot(grvi_rast, col = harrypotter::hp(n=100, option = "Slytherin"))
```

let's check the GRVI for a ground truth pile

```{r}
# check it with the ortho
grvi_rast %>% 
  terra::crop(stand_temp %>% sf::st_buffer(20)) %>% 
  terra::as.data.frame(xy=T) %>% 
  dplyr::rename(f=3) %>% 
  ggplot2::ggplot() +
  ggplot2::geom_tile(ggplot2::aes(x=x,y=y,fill = f), color = NA) +
  scale_fill_gradient2(low = "black", high = "forestgreen") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  ggplot2::theme_void() +
  theme(
      legend.position = "none" # c(0.5,1)
      , legend.direction = "horizontal"
      , legend.margin = margin(0,0,0,0)
      , legend.text = element_text(size = 8)
      , legend.title = element_text(size = 8)
      , legend.key = element_rect(fill = "white")
      # , plot.title = ggtext::element_markdown(size = 10, hjust = 0.5)
      , plot.title = element_text(size = 10, hjust = 0.5, face = "bold")
      , plot.subtitle = element_text(size = 8, hjust = 0.5, face = "italic")
    )

ggsave("../data/pile_grvi.jpeg", height = 5, width = 5)
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
remove(f, r3dDefaults, m)
gc()
```

## Study area imagery

let's look at the RGB imagery and pile locations

```{r}
# get the base plot
plt_rgb_ortho <- ortho_plt_fn(
  stand = 
    slash_piles_points %>% 
    sf::st_bbox() %>% 
    sf::st_as_sfc() %>% 
    sf::st_buffer(50) %>% 
    sf::st_transform(terra::crs(ortho_rast))
)
# add pile locations
plt_rgb_ortho +
  ggplot2::geom_sf(
    data = slash_piles_points %>% sf::st_transform(terra::crs(ortho_rast))
    , ggplot2::aes() # size = diameter
    , shape = 1
    , color = "firebrick"
  ) +
  ggplot2::theme(legend.position = "none")
```

notice these are point measurements of plot locations and the points are not precisely in the center of the pile. notice also there are piles in the imagery that were not measured (e.g. upper-left corner)

we created image-annotated pile polygons using the RBG and field-collected pile location data to compare against our predicted slash pile segments using an intersection over union (IoU) approach

let's make a panel of plots for each pile

```{r}
p_fn_temp <- function(
    rn
    , df = slash_piles_polys %>% dplyr::filter(!is.na(comment))
    , crs = terra::crs(ortho_rast)
) {
  # scale the buffer based on the largest
  d <- df %>%
    dplyr::arrange(tolower(comment), desc(field_diameter_m)) %>% 
    dplyr::slice(rn) %>% 
    sf::st_transform(crs)
  # plt
  ortho_plt_fn(stand=d) + 
    ggplot2::geom_sf(data = d, fill = NA, color = "firebrick") +
    ggplot2::labs(
      subtitle = paste0(
        tolower(d$comment)
        , "\ndiam. = "
        , scales::comma(d$field_diameter_m, accuracy = 0.1)
        # , ", ht. = "
        # , scales::comma(d$height, accuracy = 0.1)
      )
    )
}
# add pile locations
plt_list_rgb <- 1:nrow(slash_piles_polys %>% dplyr::filter(!is.na(comment))) %>% 
  purrr::map(p_fn_temp)
```

plot tiles 

```{r, height = 10.5, width = 8}
patchwork::wrap_plots(
  sample(
    plt_list_rgb, size = as.integer(nrow(slash_piles_points)/3))
  , ncol = 5
)
ggsave("../data/pile_tiles_rgb.jpeg", height = 10.5, width = 8)
```

a challenge in using the spectral data to identify slash piles will be to develop a spectral-based method that can account for the different lighting conditions in the imagery (e.g. piles in shadows or under tree crowns). this different lighting may have also influenced the point cloud generation

## Point Cloud Data

Let's check out the point cloud data we got using UAS-SfM methods

```{r}
# directory with the downloaded .las|.laz files
f_temp <- 
  "f:\\PFDP_Data\\p4pro_images\\P4Pro_06_17_2021_half_half_optimal\\2_densification\\point_cloud"
  # system.file(package = "lidR", "extdata", "Megaplot.laz")
# is there data?
list.files(f_temp, pattern = ".*\\.(laz|las)$") %>% length()
# what files are in here?
list.files(f_temp, pattern = ".*\\.(laz|las)$")[1]
```

what information does `lidR` read from the catalog?

```{r}
las_ctg <- lidR::readLAScatalog(f_temp)
# set the processing options
lidR::opt_progress(las_ctg) <- F
lidR::opt_filter(las_ctg) <- "-drop_duplicates"
lidR::opt_select(las_ctg) <- "xyziRGB"
# huh?
las_ctg
```

that's a lot of points...can an ordinary laptop handle it? we'll find out.

We'll plot our point cloud data tiles real quick to orient ourselves

```{r}
las_ctg %>% 
  purrr::pluck("data") %>% 
  mapview::mapview(popup = F, layer.name = "point cloud tile")
```

## Check out one pile

```{r}
las_temp <- lidR::clip_roi(
  las_ctg
  # biggest mechanical
  , slash_piles_polys %>%
    dplyr::filter(tolower(comment)=="mechanical pile") %>% 
    dplyr::arrange(desc(field_diameter_m)) %>% 
    dplyr::slice(1) %>% 
    sf::st_point_on_surface() %>% 
    sf::st_buffer(10, endCapStyle = "SQUARE") %>% 
    sf::st_transform(lidR::st_crs(las_ctg))
)
```

what did we get?

```{r}
las_temp@data %>% dplyr::glimpse()
```

plot a sample

```{r,echo=FALSE,message=FALSE,warning=FALSE}
## if want to get current rgl parameters
# rgl::par3d()$zoom
# rgl::par3d()$FOV
# rgl::par3d()$userMatrix %>% c()
# rgl::par3d()$windowRect
## set up for printing rgl graphics
r3dDefaults <- rgl::r3dDefaults
m  <- structure(c(
  -0.39951634,0.09665099, -0.91161686,0.00000000, -0.90745372,0.09938181,0.40822852,0.00000000,0.13005376,0.99034417,0.04800174,0.00000000,0.00000000,0.00000000
,0.00000000,1.00000000
), .Dim = c(4L, 4L))
r3dDefaults$FOV <- 30
r3dDefaults$userMatrix <- m
r3dDefaults$zoom <- 0.78
r3dDefaults$windowRect <- c(0,23,1536,864)
rgl::setupKnitr(autoprint = TRUE)
```

```{r, rgl = TRUE}
las_temp %>% 
  lidR::plot(
    color = "Z", bg = "white", legend = F
   , pal = harrypotter::hp(n=50, house = "gryffindor")
  )
```

make a gif

```{r}
library(magick)
if(!file.exists(file.path("../data/", "pile_z.gif"))){
  rgl::close3d()
  lidR::plot(
    las_temp, color = "Z", bg = "white", legend = F
   , pal = harrypotter::hp(n=50, house = "gryffindor")
  )
  rgl::movie3d( rgl::spin3d(), duration = 10, fps = 10 , movie = "pile_z", dir = "../data/")
  rgl::close3d()
}
```

```{r}
library(magick)
if(!file.exists(file.path("../data/", "pile_rgb.gif"))){
  rgl::close3d()
  lidR::plot(
    las_temp, color = "RGB", bg = "white", legend = F
  )
  rgl::movie3d( rgl::spin3d(), duration = 10, fps = 10 , movie = "pile_rgb", dir = "../data/")
  rgl::close3d()
}
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
remove(f, r3dDefaults, m)
gc()
```
